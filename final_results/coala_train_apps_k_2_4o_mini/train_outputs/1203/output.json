{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '3 3', '1 2', '2 1', '3 2'] Output: 0\n2\n2\n\nTests failed:\nNone",
    "code": "\ndef precompute_factorials(n, mod):\n    # Precompute factorials and inverse factorials\n    factorial = [1] * (n + 1)\n    inverse_factorial = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n    \n    inverse_factorial[n] = pow(factorial[n], mod - 2, mod)  # Fermat's little theorem\n    for i in range(n - 1, 0, -1):\n        inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % mod\n    \n    return factorial, inverse_factorial\n\ndef count_subsets(N, queries):\n    MOD = 10**9 + 7\n    factorial, inverse_factorial = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less = I - 1\n            count_greater = N - I\n            \n            # Calculate combinations C(count_less, K-1)\n            ways_to_choose = (factorial[count_less] * inverse_factorial[K - 1] % MOD * inverse_factorial[count_less - (K - 1)] % MOD) if count_less >= K - 1 else 0\n            \n            # Total subsets = ways_to_choose * (2 ** count_greater)\n            total_subsets = ways_to_choose * pow(2, count_greater, MOD) % MOD\n            results.append(total_subsets)\n    \n    # Print all results\n    print(\"\\n\".join(map(str, results)))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Number of test cases\n    index = 1\n    for _ in range(T):\n        N, Q = map(int, data[index].split())\n        queries = []\n        for j in range(Q):\n            I, K = map(int, data[index + 1 + j].split())\n            queries.append((I, K))\n        index += 1 + Q\n        count_subsets(N, queries)\n\n# Call the main function to execute the program\nmain()\n",
    "full_code": "\ndef precompute_factorials(n, mod):\n    # Precompute factorials and inverse factorials\n    factorial = [1] * (n + 1)\n    inverse_factorial = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n    \n    inverse_factorial[n] = pow(factorial[n], mod - 2, mod)  # Fermat's little theorem\n    for i in range(n - 1, 0, -1):\n        inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % mod\n    \n    return factorial, inverse_factorial\n\ndef count_subsets(N, queries):\n    MOD = 10**9 + 7\n    factorial, inverse_factorial = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less = I - 1\n            count_greater = N - I\n            \n            # Calculate combinations C(count_less, K-1)\n            ways_to_choose = (factorial[count_less] * inverse_factorial[K - 1] % MOD * inverse_factorial[count_less - (K - 1)] % MOD) if count_less >= K - 1 else 0\n            \n            # Total subsets = ways_to_choose * (2 ** count_greater)\n            total_subsets = ways_to_choose * pow(2, count_greater, MOD) % MOD\n            results.append(total_subsets)\n    \n    # Print all results\n    print(\"\\n\".join(map(str, results)))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Number of test cases\n    index = 1\n    for _ in range(T):\n        N, Q = map(int, data[index].split())\n        queries = []\n        for j in range(Q):\n            I, K = map(int, data[index + 1 + j].split())\n            queries.append((I, K))\n        index += 1 + Q\n        count_subsets(N, queries)\n\n# Call the main function to execute the program\nmain()\n",
    "reward": true,
    "program_code": "\ndef precompute_factorials(n, mod):\n    # Precompute factorials and inverse factorials\n    factorial = [1] * (n + 1)\n    inverse_factorial = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n    \n    inverse_factorial[n] = pow(factorial[n], mod - 2, mod)  # Fermat's little theorem\n    for i in range(n - 1, 0, -1):\n        inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % mod\n    \n    return factorial, inverse_factorial\n\ndef count_subsets(N, queries):\n    MOD = 10**9 + 7\n    factorial, inverse_factorial = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less = I - 1\n            count_greater = N - I\n            \n            # Calculate combinations C(count_less, K-1)\n            ways_to_choose = (factorial[count_less] * inverse_factorial[K - 1] % MOD * inverse_factorial[count_less - (K - 1)] % MOD) if count_less >= K - 1 else 0\n            \n            # Total subsets = ways_to_choose * (2 ** count_greater)\n            total_subsets = ways_to_choose * pow(2, count_greater, MOD) % MOD\n            results.append(total_subsets)\n    \n    # Print all results\n    print(\"\\n\".join(map(str, results)))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Number of test cases\n    index = 1\n    for _ in range(T):\n        N, Q = map(int, data[index].split())\n        queries = []\n        for j in range(Q):\n            I, K = map(int, data[index + 1 + j].split())\n            queries.append((I, K))\n        index += 1 + Q\n        count_subsets(N, queries)\n\n# Call the main function to execute the program\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n   We need to find the number of subsets from a set of natural numbers {1, 2, ..., N} such that a specific number I appears at the K-th position in the sorted order of the subset. We will handle multiple queries for each test case, and the results should be printed modulo \\(10^9 + 7\\).\n\n2. **Conceptualize a solution first in plain English:**\n   To solve this problem, we need to understand how to count the valid subsets:\n   - For a number I to be at the K-th position in a subset, there must be exactly K-1 numbers that are less than I in the subset.\n   - The remaining numbers in the subset can be any of the numbers greater than I.\n   - We can use combinatorial counting to determine how many ways we can choose K-1 numbers from the numbers less than I and any number of elements from those greater than I.\n   - The total number of valid subsets can be calculated using combinations and powers of 2.\n\n3. **Write a pseudocode solution:**\n   ```\n   function count_subsets(N, queries):\n       MOD = 10**9 + 7\n       precompute factorials and inverse factorials up to N\n       \n       for each query (I, K):\n           if K > I or K < 1:\n               print 0\n           else:\n               count_less = I - 1\n               count_greater = N - I\n               # Calculate combinations C(count_less, K-1)\n               ways_to_choose = factorial[count_less] * inverse_factorial[K-1] * inverse_factorial[count_less - (K-1)] % MOD\n               # Total subsets = ways_to_choose * (2 ** count_greater)\n               total_subsets = ways_to_choose * pow(2, count_greater, MOD) % MOD\n               print total_subsets\n\n   function main():\n       read T\n       for each test case:\n           read N, Q\n           read queries\n           count_subsets(N, queries)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef precompute_factorials(n, mod):\n    # Precompute factorials and inverse factorials\n    factorial = [1] * (n + 1)\n    inverse_factorial = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n    \n    inverse_factorial[n] = pow(factorial[n], mod - 2, mod)  # Fermat's little theorem\n    for i in range(n - 1, 0, -1):\n        inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % mod\n    \n    return factorial, inverse_factorial\n\ndef count_subsets(N, queries):\n    MOD = 10**9 + 7\n    factorial, inverse_factorial = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less = I - 1\n            count_greater = N - I\n            \n            # Calculate combinations C(count_less, K-1)\n            ways_to_choose = (factorial[count_less] * inverse_factorial[K - 1] % MOD * inverse_factorial[count_less - (K - 1)] % MOD) if count_less >= K - 1 else 0\n            \n            # Total subsets = ways_to_choose * (2 ** count_greater)\n            total_subsets = ways_to_choose * pow(2, count_greater, MOD) % MOD\n            results.append(total_subsets)\n    \n    # Print all results\n    print(\"\\n\".join(map(str, results)))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Number of test cases\n    index = 1\n    for _ in range(T):\n        N, Q = map(int, data[index].split())\n        queries = []\n        for j in range(Q):\n            I, K = map(int, data[index + 1 + j].split())\n            queries.append((I, K))\n        index += 1 + Q\n        count_subsets(N, queries)\n\n# Call the main function to execute the program\nmain()\n```",
    "no_parent": false,
    "dependency_used": false
}