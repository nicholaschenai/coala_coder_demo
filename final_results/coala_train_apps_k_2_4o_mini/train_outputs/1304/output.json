{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 2', '3 1 2', '2 3 1', ''] Output: 3 2 1\n3 1 2 \n\nTests failed:\nNone",
    "code": "\ndef next_permutation(permutation):\n    # Step 1: Find the largest index i such that permutation[i] < permutation[i + 1]\n    i = len(permutation) - 2\n    while i >= 0 and permutation[i] >= permutation[i + 1]:\n        i -= 1\n    \n    if i == -1:\n        # This is the last permutation, return the sorted order\n        return sorted(permutation)\n    \n    # Step 2: Find the largest index j greater than i such that permutation[i] < permutation[j]\n    j = len(permutation) - 1\n    while permutation[j] <= permutation[i]:\n        j -= 1\n    \n    # Step 3: Swap the value of permutation[i] with that of permutation[j]\n    permutation[i], permutation[j] = permutation[j], permutation[i]\n    \n    # Step 4: Reverse the sequence from permutation[i + 1] to the end\n    permutation[i + 1:] = reversed(permutation[i + 1:])\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and K\n    N, K = map(int, data[0].split())\n    results = []\n    \n    # Process each permutation\n    for i in range(1, K + 1):\n        permutation = list(map(int, data[i].split()))\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results\n    print(\"\\n\".join(results))\n\n# Call the main function to execute the program\nmain()\n",
    "full_code": "\ndef next_permutation(permutation):\n    # Step 1: Find the largest index i such that permutation[i] < permutation[i + 1]\n    i = len(permutation) - 2\n    while i >= 0 and permutation[i] >= permutation[i + 1]:\n        i -= 1\n    \n    if i == -1:\n        # This is the last permutation, return the sorted order\n        return sorted(permutation)\n    \n    # Step 2: Find the largest index j greater than i such that permutation[i] < permutation[j]\n    j = len(permutation) - 1\n    while permutation[j] <= permutation[i]:\n        j -= 1\n    \n    # Step 3: Swap the value of permutation[i] with that of permutation[j]\n    permutation[i], permutation[j] = permutation[j], permutation[i]\n    \n    # Step 4: Reverse the sequence from permutation[i + 1] to the end\n    permutation[i + 1:] = reversed(permutation[i + 1:])\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and K\n    N, K = map(int, data[0].split())\n    results = []\n    \n    # Process each permutation\n    for i in range(1, K + 1):\n        permutation = list(map(int, data[i].split()))\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results\n    print(\"\\n\".join(results))\n\n# Call the main function to execute the program\nmain()\n",
    "reward": true,
    "program_code": "\ndef next_permutation(permutation):\n    # Step 1: Find the largest index i such that permutation[i] < permutation[i + 1]\n    i = len(permutation) - 2\n    while i >= 0 and permutation[i] >= permutation[i + 1]:\n        i -= 1\n    \n    if i == -1:\n        # This is the last permutation, return the sorted order\n        return sorted(permutation)\n    \n    # Step 2: Find the largest index j greater than i such that permutation[i] < permutation[j]\n    j = len(permutation) - 1\n    while permutation[j] <= permutation[i]:\n        j -= 1\n    \n    # Step 3: Swap the value of permutation[i] with that of permutation[j]\n    permutation[i], permutation[j] = permutation[j], permutation[i]\n    \n    # Step 4: Reverse the sequence from permutation[i + 1] to the end\n    permutation[i + 1:] = reversed(permutation[i + 1:])\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and K\n    N, K = map(int, data[0].split())\n    results = []\n    \n    # Process each permutation\n    for i in range(1, K + 1):\n        permutation = list(map(int, data[i].split()))\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results\n    print(\"\\n\".join(results))\n\n# Call the main function to execute the program\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n   We need to find the next permutation of a given sequence of numbers from 1 to N in lexicographic order. Given multiple permutations, we will output the next permutation for each one.\n\n2. **Conceptualize a solution first in plain English:**\n   To find the next permutation in lexicographic order, we can follow these steps:\n   - Identify the longest suffix that is non-increasing (i.e., find the rightmost pair where the first number is less than the second).\n   - If such a pair is found, swap the first number of this pair with the smallest number in the suffix that is larger than it.\n   - Finally, reverse the suffix to get the next permutation.\n   - If no such pair exists, it means we are at the last permutation, and we should return the smallest permutation (sorted order).\n\n3. **Write a pseudocode solution:**\n   ```\n   function next_permutation(permutation):\n       # Step 1: Find the largest index i such that permutation[i] < permutation[i + 1]\n       i = length(permutation) - 2\n       while i >= 0 and permutation[i] >= permutation[i + 1]:\n           i -= 1\n       \n       if i == -1:\n           # This is the last permutation, return the sorted order\n           return sorted(permutation)\n       \n       # Step 2: Find the largest index j greater than i such that permutation[i] < permutation[j]\n       j = length(permutation) - 1\n       while permutation[j] <= permutation[i]:\n           j -= 1\n       \n       # Step 3: Swap the value of permutation[i] with that of permutation[j]\n       swap(permutation[i], permutation[j])\n       \n       # Step 4: Reverse the sequence from permutation[i + 1] to the end\n       reverse(permutation, i + 1, end)\n       \n       return permutation\n\n   function main():\n       read N and K\n       for each permutation in K:\n           result = next_permutation(permutation)\n           print(result)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef next_permutation(permutation):\n    # Step 1: Find the largest index i such that permutation[i] < permutation[i + 1]\n    i = len(permutation) - 2\n    while i >= 0 and permutation[i] >= permutation[i + 1]:\n        i -= 1\n    \n    if i == -1:\n        # This is the last permutation, return the sorted order\n        return sorted(permutation)\n    \n    # Step 2: Find the largest index j greater than i such that permutation[i] < permutation[j]\n    j = len(permutation) - 1\n    while permutation[j] <= permutation[i]:\n        j -= 1\n    \n    # Step 3: Swap the value of permutation[i] with that of permutation[j]\n    permutation[i], permutation[j] = permutation[j], permutation[i]\n    \n    # Step 4: Reverse the sequence from permutation[i + 1] to the end\n    permutation[i + 1:] = reversed(permutation[i + 1:])\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and K\n    N, K = map(int, data[0].split())\n    results = []\n    \n    # Process each permutation\n    for i in range(1, K + 1):\n        permutation = list(map(int, data[i].split()))\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results\n    print(\"\\n\".join(results))\n\n# Call the main function to execute the program\nmain()\n```",
    "no_parent": false,
    "dependency_used": false
}