{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[2, 2, 2, 1, 1]] Output: True\n\nTests failed:\nNone",
    "code": "\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, we cannot form a square\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Define a backtracking function to try to build the square\n        def backtrack(index):\n            # If we have used all matchsticks, check if all sides are equal to side_length\n            if index == len(nums):\n                return all(side == side_length for side in sides)\n            \n            # Try to place the current matchstick in each side\n            for i in range(4):\n                # If adding the matchstick does not exceed the side length\n                if sides[i] + nums[index] <= side_length:\n                    sides[i] += nums[index]  # Add matchstick to the side\n                    if backtrack(index + 1):  # Recur to place the next matchstick\n                        return True\n                    sides[i] -= nums[index]  # Backtrack: remove the matchstick\n            \n            return False  # If no placement worked, return false\n        \n        # Start backtracking from the first matchstick\n        return backtrack(0)\n",
    "full_code": "\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, we cannot form a square\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Define a backtracking function to try to build the square\n        def backtrack(index):\n            # If we have used all matchsticks, check if all sides are equal to side_length\n            if index == len(nums):\n                return all(side == side_length for side in sides)\n            \n            # Try to place the current matchstick in each side\n            for i in range(4):\n                # If adding the matchstick does not exceed the side length\n                if sides[i] + nums[index] <= side_length:\n                    sides[i] += nums[index]  # Add matchstick to the side\n                    if backtrack(index + 1):  # Recur to place the next matchstick\n                        return True\n                    sides[i] -= nums[index]  # Backtrack: remove the matchstick\n            \n            return False  # If no placement worked, return false\n        \n        # Start backtracking from the first matchstick\n        return backtrack(0)\n",
    "reward": true,
    "program_code": "\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, we cannot form a square\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Define a backtracking function to try to build the square\n        def backtrack(index):\n            # If we have used all matchsticks, check if all sides are equal to side_length\n            if index == len(nums):\n                return all(side == side_length for side in sides)\n            \n            # Try to place the current matchstick in each side\n            for i in range(4):\n                # If adding the matchstick does not exceed the side length\n                if sides[i] + nums[index] <= side_length:\n                    sides[i] += nums[index]  # Add matchstick to the side\n                    if backtrack(index + 1):  # Recur to place the next matchstick\n                        return True\n                    sides[i] -= nums[index]  # Backtrack: remove the matchstick\n            \n            return False  # If no placement worked, return false\n        \n        # Start backtracking from the first matchstick\n        return backtrack(0)\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: \n   The task is to determine if a given set of matchsticks can be arranged to form a perfect square. Each matchstick has a specific length, and we must use all of them without breaking any. The output should be true if it's possible to form a square and false otherwise.\n\n2. **Conceptualize a solution first in plain English**: \n   To solve this problem, we need to check if the total length of the matchsticks can be evenly divided into four equal sides, as a square has four sides of equal length. If the total length is not divisible by four, we can immediately return false. If it is divisible, we can use a backtracking approach to try to build the four sides of the square using the matchsticks. We will recursively attempt to add matchsticks to each side and check if we can successfully use all matchsticks to form the square.\n\n3. **Write a pseudocode solution**:\n   ```\n   function makesquare(matchsticks):\n       total_length = sum(matchsticks)\n       if total_length % 4 != 0:\n           return false\n       side_length = total_length / 4\n       sort matchsticks in descending order\n       initialize sides array of size 4 with 0\n       \n       function backtrack(index):\n           if index == length of matchsticks:\n               return all sides are equal to side_length\n           for each side in sides:\n               if adding matchstick[index] to side does not exceed side_length:\n                   add matchstick[index] to side\n                   if backtrack(index + 1) is true:\n                       return true\n                   remove matchstick[index] from side\n           return false\n       \n       return backtrack(0)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, we cannot form a square\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Define a backtracking function to try to build the square\n        def backtrack(index):\n            # If we have used all matchsticks, check if all sides are equal to side_length\n            if index == len(nums):\n                return all(side == side_length for side in sides)\n            \n            # Try to place the current matchstick in each side\n            for i in range(4):\n                # If adding the matchstick does not exceed the side length\n                if sides[i] + nums[index] <= side_length:\n                    sides[i] += nums[index]  # Add matchstick to the side\n                    if backtrack(index + 1):  # Recur to place the next matchstick\n                        return True\n                    sides[i] -= nums[index]  # Backtrack: remove the matchstick\n            \n            return False  # If no placement worked, return false\n        \n        # Start backtracking from the first matchstick\n        return backtrack(0)\n```",
    "no_parent": false,
    "dependency_used": false
}