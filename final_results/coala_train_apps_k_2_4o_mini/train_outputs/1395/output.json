{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '2 6'] Output: 3\n\nTests failed:\nNone",
    "code": "\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count the divisor\n            if i != n // i:  # Check if it's not a perfect square\n                count += 1  # Count the complementary divisor\n    return count\n\ndef find_cheating_values(T, test_cases):\n    for A, B in test_cases:\n        if A == B:  # If both roll numbers are the same\n            print(-1)  # Infinite values of p\n        else:\n            difference = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(difference)  # Count the divisors of the difference\n            print(divisors_count)  # Output the count of valid p values\n\n# Read the number of test cases\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    A, B = map(int, input().split())  # Read each pair of roll numbers\n    test_cases.append((A, B))  # Store the test cases\n\nfind_cheating_values(T, test_cases)  # Process the test cases\n",
    "full_code": "\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count the divisor\n            if i != n // i:  # Check if it's not a perfect square\n                count += 1  # Count the complementary divisor\n    return count\n\ndef find_cheating_values(T, test_cases):\n    for A, B in test_cases:\n        if A == B:  # If both roll numbers are the same\n            print(-1)  # Infinite values of p\n        else:\n            difference = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(difference)  # Count the divisors of the difference\n            print(divisors_count)  # Output the count of valid p values\n\n# Read the number of test cases\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    A, B = map(int, input().split())  # Read each pair of roll numbers\n    test_cases.append((A, B))  # Store the test cases\n\nfind_cheating_values(T, test_cases)  # Process the test cases\n",
    "reward": true,
    "program_code": "\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count the divisor\n            if i != n // i:  # Check if it's not a perfect square\n                count += 1  # Count the complementary divisor\n    return count\n\ndef find_cheating_values(T, test_cases):\n    for A, B in test_cases:\n        if A == B:  # If both roll numbers are the same\n            print(-1)  # Infinite values of p\n        else:\n            difference = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(difference)  # Count the divisors of the difference\n            print(divisors_count)  # Output the count of valid p values\n\n# Read the number of test cases\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    A, B = map(int, input().split())  # Read each pair of roll numbers\n    test_cases.append((A, B))  # Store the test cases\n\nfind_cheating_values(T, test_cases)  # Process the test cases\n",
    "program_name": "find_cheating_values",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**:\n   Ram and Shyam have distinct roll numbers, and they receive exam question sets based on their roll numbers. The question set they receive is determined by the formula `((roll_number - 1) % p)`, where `p` is the total number of different question sets. We need to find out how many values of `p` allow both Ram and Shyam to receive the same set of questions. If there are infinitely many such values, we should return -1.\n\n2. **Conceptualize a solution first in plain English**:\n   To determine the values of `p` for which Ram and Shyam can cheat, we need to ensure that the results of the modulo operation for both their roll numbers are equal. This means we need to find values of `p` such that:\n   ```\n   (A - 1) % p == (B - 1) % p\n   ```\n   This can be simplified to:\n   ```\n   (A - B) % p == 0\n   ```\n   This indicates that `p` must be a divisor of the absolute difference between their roll numbers, `|A - B|`. If `A` equals `B`, then they will always receive the same set for any positive `p`, leading to an infinite number of valid `p` values. If `A` is not equal to `B`, we can count the number of divisors of `|A - B|` to find the valid values of `p`.\n\n3. **Write a pseudocode solution**:\n   ```\n   function count_divisors(n):\n       count = 0\n       for i from 1 to sqrt(n):\n           if n % i == 0:\n               count += 1\n               if i != n / i:\n                   count += 1\n       return count\n\n   function find_cheating_values(T, test_cases):\n       for each test case:\n           A, B = test case\n           if A == B:\n               print(-1)\n           else:\n               difference = abs(A - B)\n               divisors_count = count_divisors(difference)\n               print(divisors_count)\n\n   read T\n   for i from 1 to T:\n       read A, B\n       add (A, B) to test_cases\n   find_cheating_values(T, test_cases)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count the divisor\n            if i != n // i:  # Check if it's not a perfect square\n                count += 1  # Count the complementary divisor\n    return count\n\ndef find_cheating_values(T, test_cases):\n    for A, B in test_cases:\n        if A == B:  # If both roll numbers are the same\n            print(-1)  # Infinite values of p\n        else:\n            difference = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(difference)  # Count the divisors of the difference\n            print(divisors_count)  # Output the count of valid p values\n\n# Read the number of test cases\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    A, B = map(int, input().split())  # Read each pair of roll numbers\n    test_cases.append((A, B))  # Store the test cases\n\nfind_cheating_values(T, test_cases)  # Process the test cases\n```",
    "no_parent": false,
    "dependency_used": false
}