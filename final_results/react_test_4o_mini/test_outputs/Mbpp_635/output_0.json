{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nTests failed:\nNone",
    "code": "\ndef heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n        heapify(arr, n, largest)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr, n):\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\ndef heap_sort(arr):\n    n = len(arr)  # Get the number of elements in the array\n    build_max_heap(arr, n)  # Build a max heap\n\n    # One by one extract elements from heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Move current root to end\n        heapify(arr, i, 0)  # call max heapify on the reduced heap\n\n    return arr  # Return the sorted array\n",
    "full_code": "\ndef heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n        heapify(arr, n, largest)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr, n):\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\ndef heap_sort(arr):\n    n = len(arr)  # Get the number of elements in the array\n    build_max_heap(arr, n)  # Build a max heap\n\n    # One by one extract elements from heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Move current root to end\n        heapify(arr, i, 0)  # call max heapify on the reduced heap\n\n    return arr  # Return the sorted array\n",
    "reward": true,
    "program_code": "\ndef heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n        heapify(arr, n, largest)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr, n):\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\ndef heap_sort(arr):\n    n = len(arr)  # Get the number of elements in the array\n    build_max_heap(arr, n)  # Build a max heap\n\n    # One by one extract elements from heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Move current root to end\n        heapify(arr, i, 0)  # call max heapify on the reduced heap\n\n    return arr  # Return the sorted array\n",
    "program_name": "heap_sort",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n   We need to create a function called `heap_sort` that takes a list of numbers as input and returns a new list with those numbers sorted in ascending order.\n\n2. **Conceptualize a solution first in plain English:**\n   To sort the list using the heap sort algorithm, we will:\n   - Build a max heap from the input list.\n   - Repeatedly extract the maximum element from the heap and place it at the end of the list.\n   - Adjust the heap after each extraction to maintain the heap property.\n   - The result will be a sorted list.\n\n3. **Write a pseudocode solution:**\n   ```\n   function heap_sort(arr):\n       n = length of arr\n       build_max_heap(arr, n)\n       for i from n-1 down to 1:\n           swap arr[0] with arr[i]\n           heapify(arr, 0, i)\n       return arr\n\n   function build_max_heap(arr, n):\n       for i from n//2 - 1 down to 0:\n           heapify(arr, i, n)\n\n   function heapify(arr, i, n):\n       largest = i\n       left = 2*i + 1\n       right = 2*i + 2\n       if left < n and arr[left] > arr[largest]:\n           largest = left\n       if right < n and arr[right] > arr[largest]:\n           largest = right\n       if largest != i:\n           swap arr[i] with arr[largest]\n           heapify(arr, largest, n)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n        heapify(arr, n, largest)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr, n):\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\ndef heap_sort(arr):\n    n = len(arr)  # Get the number of elements in the array\n    build_max_heap(arr, n)  # Build a max heap\n\n    # One by one extract elements from heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Move current root to end\n        heapify(arr, i, 0)  # call max heapify on the reduced heap\n\n    return arr  # Return the sorted array\n```",
    "no_parent": true,
    "dependency_used": false
}