{"date": "2025-01-02 14:57", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/102": [{"task_id": "Mbpp/102", "solution": "\ndef snake_to_camel(snake_str: str) -> str:\n    # Split the input string by underscores to get individual words\n    words = snake_str.split('_')\n    \n    # Create an empty list to hold the capitalized words\n    capitalized_words = []\n    \n    # Capitalize the first letter of each word and add to the list\n    for word in words:\n        capitalized_words.append(word.capitalize())\n    \n    # Join the list of capitalized words into a single string\n    camel_case_str = ''.join(capitalized_words)\n    \n    # Return the resulting camel case string\n    return camel_case_str\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "\ndef is_palindrome(num):\n    # Convert the number to a string\n    s = str(num)\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n\ndef next_smallest_palindrome(n):\n    # Start checking from the next integer\n    current_number = n + 1\n    # Loop indefinitely until we find a palindrome\n    while True:\n        # If the current number is a palindrome, return it\n        if is_palindrome(current_number):\n            return current_number\n        # Increment the current number to check the next one\n        current_number += 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "\ndef kth_element(array, k):\n    # Check if k is less than 1 or greater than the length of the array\n    if k < 1 or k > len(array):\n        return None  # or raise an error, depending on requirements\n    # Return the element at index k-1 (1-based to 0-based index conversion)\n    return array[k - 1]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "\ndef count(boolean_list):\n    # Initialize a counter to keep track of True values\n    count = 0\n    # Iterate through each boolean in the provided list\n    for boolean in boolean_list:\n        # If the current boolean is True, increment the counter\n        if boolean is True:\n            count += 1\n    # Return the final count of True values\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "\ndef merge_sorted_list(list1, list2, list3):\n    # Step 1: Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Step 2: Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    # Step 3: Return the sorted list\n    return sorted_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "\ndef eulerian_num(n: int, m: int) -> int:\n    # Base case: if m is 0, there is exactly one permutation with no ascents\n    if m == 0:\n        return 1\n    # Base case: if n equals m, there are no permutations with n ascents\n    if n == m:\n        return 0\n    # Recursive case: use the recurrence relation to calculate the Eulerian number\n    return (m + 1) * eulerian_num(n - 1, m) + (n - m) * eulerian_num(n - 1, m - 1)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 0]]}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "\ndef sort_sublists(input_list):\n    # Create an empty list to hold the sorted sublists\n    sorted_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Sort the current sublist\n        sorted_sublist = sorted(sublist)\n        # Append the sorted sublist to the sorted_list\n        sorted_list.append(sorted_sublist)\n    \n    # Return the list of sorted sublists\n    return sorted_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "\ndef add_lists(lst, tup):\n    # Convert the tuple to a list\n    result_list = list(tup)\n    # Append the elements of the list to the result list\n    result_list.extend(lst)\n    # Convert the combined list back to a tuple\n    result_tuple = tuple(result_list)\n    # Return the new tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "\ndef rotate_string(s: str, n: int) -> str:\n    # Rotate the string s to the right by n positions\n    n = n % len(s)  # To handle cases where n is greater than the length of s\n    return s[-n:] + s[:-n]\n\ndef odd_Equivalent(binary_string: str, rotations: int) -> int:\n    # Create a set to store unique odd decimal values\n    odd_values = set()\n    \n    # Generate all rotations and check their decimal values\n    for i in range(rotations):\n        rotated = rotate_string(binary_string, i)\n        decimal_value = int(rotated, 2)  # Convert binary string to decimal\n        if decimal_value % 2 == 1:  # Check if the decimal value is odd\n            odd_values.add(decimal_value)  # Add to the set of unique odd values\n    \n    # Return the count of unique odd values\n    return len(odd_values)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1010", 4]], "plus_fail_tests": [["10000100110011", 5]]}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "\ndef remove_Occ(string: str, char: str) -> str:\n    # Find the index of the first occurrence of the character\n    first_index = string.find(char)\n    # Find the index of the last occurrence of the character\n    last_index = string.rfind(char)\n    \n    # Check if both occurrences are found\n    if first_index != -1 and last_index != -1:\n        # Create a new string excluding the first and last occurrence\n        new_string = string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]\n        return new_string\n    else:\n        # If the character is not found, return the original string\n        return string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "\ndef tuple_to_int(tup):\n    # Initialize an empty string to hold the concatenated result\n    result_str = \"\"\n    \n    # Loop through each integer in the tuple\n    for num in tup:\n        # Convert the integer to a string and append it to the result string\n        result_str += str(num)\n    \n    # Convert the final concatenated string back to an integer\n    result_int = int(result_str)\n    \n    # Return the resulting integer\n    return result_int\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "\ndef common_in_nested_lists(nested_lists):\n    # Check if the input list is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize a list to hold common elements\n    common_elements = []\n    \n    # Take the first inner list as the reference list\n    reference_list = nested_lists[0]\n    \n    # Iterate through each element in the reference list\n    for element in reference_list:\n        is_common = True  # Assume the element is common\n        \n        # Check if the element is present in all other inner lists\n        for inner_list in nested_lists:\n            if element not in inner_list:\n                is_common = False  # Element is not common\n                break  # No need to check further\n        \n        # If the element is common, add it to the common_elements list\n        if is_common:\n            common_elements.append(element)\n    \n    # Return the list of common elements\n    return common_elements\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "\ndef search(arr):\n    # Initialize left and right pointers\n    left = 0\n    right = len(arr) - 1\n    \n    # Perform binary search\n    while left < right:\n        mid = left + (right - left) // 2  # Find the middle index\n        \n        # Check if mid is even\n        if mid % 2 == 0:\n            # If the element at mid is equal to the next element\n            if arr[mid] == arr[mid + 1]:\n                left = mid + 2  # Move to the right half\n            else:\n                right = mid  # Move to the left half\n        else:\n            # If mid is odd\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1  # Move to the right half\n            else:\n                right = mid  # Move to the left half\n    \n    # When left meets right, we found the unique element\n    return arr[left]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "\ndef check_integer(s: str) -> bool:\n    # Check if the string is empty\n    if len(s) == 0:\n        return False\n    \n    # Check for a sign at the beginning\n    if s[0] in ['+', '-']:\n        # If there's a sign, ensure the rest of the string is not empty and consists of digits\n        return len(s) > 1 and s[1:].isdigit()\n    \n    # Check if the entire string consists of digits\n    return s.isdigit()\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "\n# Define a function named string_to_list that takes a string as input\ndef string_to_list(input_string: str) -> list:\n    # Use the split method to divide the string into a list of words\n    words_list = input_string.split()\n    # Return the list of words\n    return words_list\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "\ndef sort_matrix(matrix):\n    # Create a list of tuples where each tuple contains the sum of the row and the row itself\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples based on the first element (the sum of the row)\n    row_sums.sort(key=lambda x: x[0])\n    \n    # Create a new list to hold the sorted rows\n    sorted_matrix = []\n    \n    # Extract the rows from the sorted list of tuples\n    for _, row in row_sums:\n        sorted_matrix.append(row)\n    \n    # Return the new list of sorted rows\n    return sorted_matrix\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "\ndef max_product_tuple(tuples):\n    # Initialize a variable to keep track of the maximum absolute product\n    max_product = 0\n    \n    # Loop through each tuple in the list\n    for tup in tuples:\n        # Calculate the product of the two numbers in the tuple\n        product = tup[0] * tup[1]\n        \n        # Take the absolute value of the product\n        abs_product = abs(product)\n        \n        # If the absolute product is greater than the current maximum, update it\n        if abs_product > max_product:\n            max_product = abs_product\n            \n    # Return the maximum absolute product found\n    return max_product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "\nimport math\n\n# Define a function to calculate the angle of a complex number\ndef angle_complex(real: float, imag: float) -> float:\n    # Use the atan2 function to calculate the angle in radians\n    return math.atan2(imag, real)\n\n# Since the test case is passing a complex number, we need to adjust the function to accept a complex number directly.\ndef angle_complex(z: complex) -> float:\n    # Extract the real and imaginary parts from the complex number\n    real = z.real\n    imag = z.imag\n    # Use the atan2 function to calculate the angle in radians\n    return math.atan2(imag, real)\n\n\nimport math\n\n# Define a function to calculate the angle of a complex number\ndef angle_complex(z: complex) -> float:\n    # Extract the real and imaginary parts from the complex number\n    real = z.real\n    imag = z.imag\n    # Use the atan2 function to calculate the angle in radians\n    return math.atan2(imag, real)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "\n# Define a function to multiply two integers\ndef multiply_int(a: int, b: int) -> int:\n    # Return the product of the two integers\n    return a * b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "\ndef magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n    \n    # Calculate the target sum from the first row\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    # Check the sum of the other diagonal\n    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    \n    # Check if both diagonal sums match the target sum\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n    \n    # If all checks passed, it is a magic square\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "\ndef long_words(n: int, words_string: str) -> list:\n    # Split the input string into a list of words\n    words = words_string.split()\n    # Create an empty list to hold words longer than n characters\n    long_words_list = []\n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # Add the word to the list of long words\n            long_words_list.append(word)\n    # Return the list of long words\n    return long_words_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "\ndef max_occurrences(input_list):\n    # Create an empty dictionary to store counts\n    counts = {}\n    \n    # Count occurrences of each item in the input list\n    for item in input_list:\n        if item not in counts:\n            counts[item] = 1  # Initialize count to 1\n        else:\n            counts[item] += 1  # Increment count\n    \n    # Initialize variables to track the item with maximum frequency\n    max_count = 0\n    max_item = None\n    \n    # Find the item with the maximum count\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count  # Update max_count\n            max_item = item    # Update max_item\n    \n    return max_item  # Return the item with maximum frequency\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "\ndef find_length(binary_string: str) -> int:\n    # Initialize the maximum difference to 0\n    max_difference = 0\n    \n    # Iterate over all possible starting points for substrings\n    for start_index in range(len(binary_string)):\n        # Initialize counts of '0's and '1's for the current substring\n        count_0 = 0\n        count_1 = 0\n        \n        # Iterate over all possible ending points for substrings\n        for end_index in range(start_index, len(binary_string)):\n            # Count '0's and '1's in the current substring\n            if binary_string[end_index] == '0':\n                count_0 += 1\n            else:\n                count_1 += 1\n            \n            # Calculate the difference between counts of '0's and '1's\n            difference = count_0 - count_1\n            \n            # Update the maximum difference if the current one is greater\n            if difference > max_difference:\n                max_difference = difference\n    \n    # Return the maximum difference found\n    return max_difference\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "\ndef reverse_vowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"  # Define the vowels\n    found_vowels = []  # List to store the vowels found in the string\n    \n    # Collect all vowels from the string\n    for char in s:\n        if char in vowels:\n            found_vowels.append(char)\n    \n    # Reverse the list of found vowels\n    found_vowels.reverse()\n    \n    result = []  # List to build the result string\n    vowel_index = 0  # Index to track the position in the reversed vowels list\n    \n    # Build the result string\n    for char in s:\n        if char in vowels:\n            result.append(found_vowels[vowel_index])  # Replace with reversed vowel\n            vowel_index += 1  # Move to the next vowel in the reversed list\n        else:\n            result.append(char)  # Keep the consonant as is\n    \n    return ''.join(result)  # Join the list into a string and return\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "\ndef sum_negativenum(numbers):\n    # Initialize a variable to hold the sum of negative numbers\n    total_sum = 0\n    \n    # Iterate through each number in the provided list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the total sum\n            total_sum += number\n            \n    # Return the total sum of negative numbers\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "\n# Define a function to calculate the nth hexagonal number\ndef hexagonal_num(n):\n    # The formula for the nth hexagonal number is n * (2n - 1)\n    return n * (2 * n - 1)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "\ndef tup_string(tup):\n    # Use the join method to concatenate the characters in the tuple\n    return ''.join(tup)  # Join the elements of the tuple into a single string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "\ndef is_Sum_Of_Powers_Of_Two(n):\n    # Check if the number is less than or equal to zero\n    if n <= 0:\n        return False\n    \n    # Convert the number to binary and check if it has any '1's\n    # If n is greater than zero, it can be represented as a sum of powers of 2\n    return True\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[123456789]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "\n# Importing the value of pi from the math module\n# However, since we cannot use external libraries, we will define pi manually\nPI = 3.141592653589793\n\n# Function to calculate the circumference of a circle\ndef circle_circumference(radius: float) -> float:\n    # Calculate the circumference using the formula C = 2 * pi * r\n    circumference = 2 * PI * radius\n    # Return the calculated circumference\n    return circumference\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "\ndef flip(arr, k):\n    # This helper function reverses the order of the first k elements in arr\n    start = 0\n    while start < k:\n        arr[start], arr[k] = arr[k], arr[start]\n        start += 1\n        k -= 1\n\ndef pancake_sort(arr):\n    n = len(arr)\n    # Iterate from the end of the array to the beginning\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in arr[0..i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n        \n        # If the maximum element is not at index i, we need to flip\n        if max_index != i:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index)\n            # Now flip the maximum element to its correct position\n            flip(arr, i)\n    \n    return arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through each number in the array\n    for number in arr:\n        if number == 0:\n            # Increment zero count if the number is zero\n            zero_count += 1\n        else:\n            # Increment non-zero count if the number is not zero\n            non_zero_count += 1\n    \n    # If there are no non-zero numbers, return 0.0 to avoid division by zero\n    if non_zero_count == 0:\n        return 0.0\n    \n    # Calculate and return the ratio of zeroes to non-zeroes\n    return zero_count / non_zero_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "\ndef extract_singly(lst):\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate through each tuple in the list\n    for tup in lst:\n        # Iterate through each number in the tuple\n        for num in tup:\n            # Add the number to the set\n            unique_numbers.add(num)\n    \n    # Return the set of unique numbers\n    return unique_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "\ndef find_Volume(base_length: float, triangle_height: float, prism_height: float) -> float:\n    # Calculate the area of the triangular base\n    base_area = (1/2) * base_length * triangle_height\n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "\ndef count_samepair(list1, list2, list3):\n    # Initialize a counter to keep track of identical items\n    count = 0\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # Increment the counter if they are identical\n            count += 1\n            \n    # Return the total count of identical items\n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "\ndef max_Abs_Diff(arr):\n    # Initialize min_value to a very large number\n    min_value = float('inf')\n    # Initialize max_value to a very small number\n    max_value = float('-inf')\n    \n    # Iterate through each number in the input tuple\n    for number in arr:\n        # Update min_value if the current number is smaller\n        if number < min_value:\n            min_value = number\n        # Update max_value if the current number is larger\n        if number > max_value:\n            max_value = number\n    \n    # Return the difference between max_value and min_value\n    return max_value - min_value\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "\ndef find_solution(a: int, b: int, n: int) -> tuple[int, int] | None:\n    # Iterate through possible values of x\n    for x in range(n // a + 1):\n        # Calculate the corresponding value of y\n        if (n - a * x) % b == 0:  # Check if (n - ax) is divisible by b\n            y = (n - a * x) // b\n            if y >= 0:  # Ensure y is non-negative\n                return (x, y)  # Return the solution as a tuple\n    return None  # Return None if no solution is found\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "\nimport re\n\n# Function to check if the input string contains sequences of lowercase letters joined with an underscore\ndef text_lowercase_underscore(s: str) -> bool:\n    # Define the regex pattern for lowercase letters and underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use the fullmatch method to check if the entire string matches the pattern\n    return re.fullmatch(pattern, s) is not None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "\ndef remove_elements(list1, list2):\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate through each element in the first list\n    for element in list1:\n        # Check if the element is not in the second list\n        if element not in list2:\n            # If not, add it to the result list\n            result.append(element)\n    \n    # Return the final result list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "\ndef count_char_position(s: str) -> int:\n    # Initialize a counter for matching characters\n    count = 0\n    \n    # Iterate through each character in the string\n    for index in range(len(s)):\n        character = s[index].lower()  # Convert character to lowercase for case insensitivity\n        position = index + 1  # Position in the string (1-based index)\n        \n        # Check if the character is a letter\n        if 'a' <= character <= 'z':\n            # Calculate the alphabet position (1 for 'a', 2 for 'b', ..., 26 for 'z')\n            alphabet_position = ord(character) - ord('a') + 1\n            \n            # If the alphabet position matches the string position, increment the count\n            if alphabet_position == position:\n                count += 1\n    \n    # Return the total count of matching characters\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "\ndef find_even_pair(lst):\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd integers in the list\n    for number in lst:\n        if number % 2 == 0:  # Check if the number is even\n            even_count += 1\n        else:  # Otherwise, it is odd\n            odd_count += 1\n    \n    # Calculate the number of pairs of even integers\n    even_pairs = (even_count * (even_count - 1)) // 2\n    # Calculate the number of pairs of odd integers\n    odd_pairs = (odd_count * (odd_count - 1)) // 2\n    \n    # Return the total number of pairs that XOR to an even number\n    return even_pairs + odd_pairs\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "\ndef next_power_of_2(n: int) -> int:\n    # If n is 0, the smallest power of 2 is 1\n    if n == 0:\n        return 1\n    \n    # Start with the smallest power of 2\n    power = 1\n    \n    # Keep doubling the power until it is greater than or equal to n\n    while power < n:\n        power *= 2\n    \n    # Return the found power of 2\n    return power\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "\n# Define a function to calculate the perimeter of a square\ndef square_perimeter(side_length):\n    # Calculate the perimeter by multiplying the side length by 4\n    perimeter = side_length * 4\n    # Return the calculated perimeter\n    return perimeter\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "\ndef frequency(numbers, target):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through each number in the provided list\n    for number in numbers:\n        # Check if the current number is equal to the target number\n        if number == target:\n            # Increment the count if a match is found\n            count += 1\n    # Return the total count of occurrences\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "\ndef sum_range_list(numbers, start_index, end_index):\n    # Get the sublist from start_index to end_index (inclusive)\n    sublist = numbers[start_index:end_index + 1]\n    \n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through each number in the sublist\n    for number in sublist:\n        # Add each number to the total sum\n        total_sum += number\n    \n    # Return the final sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "\n# Define a function to calculate the perimeter of a regular pentagon\ndef perimeter_pentagon(side_length):\n    # Calculate the perimeter by multiplying the side length by 5\n    perimeter = side_length * 5\n    # Return the calculated perimeter\n    return perimeter\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "\ndef count_occurance(s: str) -> int:\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Get the length of the string\n    length = len(s)\n    # Loop through the string\n    for i in range(length - 2):  # We stop at length - 2 to avoid index out of range\n        # Check if the substring from the current index matches 'std'\n        if s[i:i+3] == 'std':\n            count += 1  # Increment the counter if a match is found\n    # Return the total count of occurrences\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "\ndef remove_dirty_chars(str1: str, str2: str) -> str:\n    # Create an empty result string to store the characters we want to keep\n    result = \"\"\n    \n    # Iterate through each character in the first string\n    for char in str1:\n        # Check if the character is not in the second string\n        if char not in str2:\n            # If it's not, append it to the result string\n            result += char\n            \n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "\ndef test_duplicate(arr):\n    # Create an empty set to keep track of seen numbers\n    seen = set()\n    \n    # Iterate through each number in the input array\n    for number in arr:\n        # Check if the number is already in the seen set\n        if number in seen:\n            # If it is, we found a duplicate, return True\n            return True\n        # Add the number to the seen set\n        seen.add(number)\n    \n    # If we finish the loop without finding duplicates, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "\ndef similar_elements(list1, list2):\n    # Create an empty list to hold the shared elements\n    shared_elements = []\n    \n    # Iterate through each element in the first list\n    for element in list1:\n        # Check if the element is in the second list\n        if element in list2:\n            # If it is, add it to the shared_elements list\n            shared_elements.append(element)\n    \n    # Return the list of shared elements\n    return shared_elements\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "\ndef sum_series(n: int) -> int:\n    # Initialize the sum variable to store the total\n    total_sum = 0\n    \n    # Loop until n is greater than 0\n    while n > 0:\n        # Add the current value of n to the total sum\n        total_sum += n\n        # Decrease n by 2 for the next iteration\n        n -= 2\n    \n    # Return the final calculated sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "\ndef find_first_index(arr, element):\n    left, right = 0, len(arr) - 1\n    first_index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == element:\n            first_index = mid\n            right = mid - 1  # continue searching in the left half\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return first_index\n\ndef find_last_index(arr, element):\n    left, right = 0, len(arr) - 1\n    last_index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == element:\n            last_index = mid\n            left = mid + 1  # continue searching in the right half\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return last_index\n\ndef is_majority(arr, n, element):\n    if n == 0:\n        return False\n    \n    first_index = find_first_index(arr, element)\n    if first_index == -1:\n        return False\n    \n    last_index = find_last_index(arr, element)\n    count = last_index - first_index + 1\n    \n    return count > n / 2\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "\ndef check_type(tup):\n    # Check if the tuple is empty\n    if not tup:\n        return True\n    \n    # Get the type of the first element as a reference\n    reference_type = type(tup[0])\n    \n    # Iterate through the tuple starting from the second element\n    for element in tup[1:]:\n        # Compare the type of each element with the reference type\n        if type(element) != reference_type:\n            return False\n    \n    # If all elements have the same type, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "\ndef count_Set_Bits(n: int) -> int:\n    # Initialize a counter to keep track of the number of set bits\n    count = 0\n    \n    # Loop until n becomes 0\n    while n > 0:\n        # Check if the least significant bit is 1\n        if n & 1 == 1:\n            count += 1  # Increment the count if it is 1\n        \n        # Right shift n by 1 to check the next bit\n        n >>= 1\n    \n    # Return the total count of set bits\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "\ndef odd_values_string(input_string):\n    # Create an empty string to store the result\n    result = \"\"\n    # Iterate through the input string with index\n    for index in range(len(input_string)):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character at the even index to the result\n            result += input_string[index]\n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "\n# Define a function to find the minimum of three numbers\ndef min_of_three(a, b, c):\n    # Initialize min_value to the first number\n    min_value = a\n    # Compare with the second number\n    if b < min_value:\n        min_value = b\n    # Compare with the third number\n    if c < min_value:\n        min_value = c\n    # Return the smallest number found\n    return min_value\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "\ndef larg_nnum(input_list, n):\n    # Step 1: Remove duplicates by converting the list to a set\n    unique_numbers = list(set(input_list))\n    \n    # Step 2: Sort the unique numbers in descending order\n    unique_numbers.sort(reverse=True)\n    \n    # Step 3: Return the first n elements from the sorted list\n    return unique_numbers[:n]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[4, 5, 3, 8, 5, 2, 6, 4], 4]]}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "\ndef sum(a: int, b: int) -> int:\n    # Determine the smaller of the two numbers\n    min_value = min(a, b)\n    # Initialize a variable to hold the sum of common divisors\n    total_sum = 0\n    # Loop through all numbers from 1 to the smaller number\n    for i in range(1, min_value + 1):\n        # Check if i is a divisor of both a and b\n        if a % i == 0 and b % i == 0:\n            # If it is, add it to the total sum\n            total_sum += i\n    # Return the total sum of common divisors\n    return total_sum\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321, 123456789]]}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "\ndef calculate_lateral_surface_area(radius: float, height: float) -> float:\n    # Define the value of pi\n    pi = 3.14159\n    # Calculate the lateral surface area using the formula\n    lateral_surface_area = 2 * pi * radius * height\n    # Return the calculated lateral surface area\n    return lateral_surface_area\n\ndef lateralsuface_cylinder(radius: float, height: float) -> float:\n    # Call the helper function to calculate the lateral surface area\n    return calculate_lateral_surface_area(radius, height)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 5]], "plus_fail_tests": [[5, 5]]}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "\ndef replace_blank(input_string: str, replacement_char: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a space, append the replacement character\n        if char == ' ':\n            result += replacement_char\n        else:\n            # Otherwise, append the original character\n            result += char\n            \n    # Return the modified string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "\n# Define a function to calculate the volume of a cube\ndef volume_cube(side_length: int) -> int:\n    # Calculate the volume by cubing the side length\n    return side_length * side_length * side_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "\ndef even_bit_set_number(n: int) -> int:\n    # Create a mask with 1s in all even bit positions\n    mask = 0\n    for i in range(0, 32, 2):  # Assuming a 32-bit integer\n        mask |= (1 << i)  # Set the i-th bit to 1\n    # Set all even bits of n to 1, but only if they are currently 0\n    return n | mask\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "\ndef check_occurences(tuples_list):\n    # Create a dictionary to count occurrences of each tuple\n    occurrences = {}\n    \n    # Count occurrences of each tuple\n    for tup in tuples_list:\n        if tup in occurrences:\n            occurrences[tup] += 1\n        else:\n            occurrences[tup] = 1\n            \n    # Create a dictionary to store the result\n    result = {}\n    \n    # Set to keep track of processed tuples\n    processed = set()\n    \n    # Iterate through the counted occurrences\n    for tup in occurrences:\n        # Check for the reverse tuple\n        reverse_tup = (tup[1], tup[0])\n        if reverse_tup in occurrences and tup not in processed:\n            # Add to result with the total count of the tuple and its reverse\n            result[tup] = occurrences[tup] + occurrences[reverse_tup]\n            # Mark both tuples as processed\n            processed.add(tup)\n            processed.add(reverse_tup)\n    \n    # Return the result dictionary\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 1], [1, 3], [2, 5], [5, 2], [6, 3]]]], "plus_fail_tests": [[[[2, 2], [1, 3], [2, 2], [3, 1], [1, 3]]]]}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "\ndef replace_list(list1, list2):\n    # Check if the first list is empty\n    if not list1:\n        return list2  # If empty, return the second list\n    \n    # Create a new list with all elements of list1 except the last one\n    new_list = list1[:-1]\n    \n    # Append all elements of list2 to the new list\n    new_list.extend(list2)\n    \n    # Return the new list\n    return new_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "\ndef number_of_substrings(s: str) -> int:\n    # Calculate the length of the string\n    n = len(s)\n    # Use the formula for the sum of the first n natural numbers to find the count of non-empty substrings\n    return n * (n + 1) // 2  # Use integer division to ensure the result is an integer\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "\n# Define a function to count the total number of characters in a string\ndef count_charac(input_string: str) -> int:\n    # Use the built-in len() function to get the length of the input string\n    return len(input_string)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "\ndef next_Perfect_Square(n):\n    # Find the integer square root of n\n    integer_sqrt = int(n**0.5)\n    # Increment the integer square root\n    next_integer = integer_sqrt + 1\n    # Square the next integer to get the next perfect square\n    next_perfect_square = next_integer * next_integer\n    # Return the next perfect square\n    return next_perfect_square\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "\n# Define a function that counts occurrences of an element in a tuple\ndef count_X(tup, element):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each item in the tuple\n    for item in tup:\n        # If the current item matches the element, increment the count\n        if item == element:\n            count += 1\n    # Return the final count\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "\ndef max_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Create arrays to store the maximum sum of increasing subsequences\n    inc_sum = [0] * n\n    # Create arrays to store the maximum sum of decreasing subsequences\n    dec_sum = [0] * n\n    \n    # Fill inc_sum array\n    for i in range(n):\n        inc_sum[i] = arr[i]  # Start with the value itself\n        for j in range(i):\n            if arr[j] < arr[i]:  # Check for increasing condition\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    \n    # Fill dec_sum array\n    for i in range(n-1, -1, -1):\n        dec_sum[i] = arr[i]  # Start with the value itself\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[i]:  # Check for decreasing condition\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    \n    # Calculate the maximum sum of bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    \n    return max_bitonic_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "\ndef insert_element(input_list, element):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in input_list:\n        # Append the specified element to the result list\n        result.append(element)\n        # Append the current item from the input list to the result list\n        result.append(item)\n    \n    # Return the resulting list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "\nimport math\n\n# Function to convert a complex number to polar coordinates\ndef convert(complex_number):\n    # Extract the real and imaginary parts\n    a = complex_number.real\n    b = complex_number.imag\n    \n    # Calculate the radius (magnitude)\n    radius = math.sqrt(a**2 + b**2)\n    \n    # Calculate the angle (phase) in radians\n    angle = math.atan2(b, a)\n    \n    # Return the polar coordinates as a tuple\n    return (radius, angle)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "\n# Define a helper function to check if an element is an integer\ndef is_integer(element):\n    return type(element) is int\n\n# Main function to count integer elements in the list\ndef count_integer(input_list):\n    count = 0  # Initialize the count of integers\n    for element in input_list:  # Iterate through each element in the list\n        if is_integer(element):  # Check if the element is an integer\n            count += 1  # Increment the count if it is an integer\n    return count  # Return the final count of integers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "\ndef lps(s: str) -> int:\n    n = len(s)  # Get the length of the input string\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array initialized to 0\n\n    # Each character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the dp table\n    for length in range(2, n + 1):  # Length of the substring\n        for start in range(n - length + 1):  # Starting index of the substring\n            end = start + length - 1  # Ending index of the substring\n            if s[start] == s[end]:  # If characters match\n                dp[start][end] = dp[start + 1][end - 1] + 2  # Include both characters\n            else:  # If characters do not match\n                dp[start][end] = max(dp[start + 1][end], dp[start][end - 1])  # Take the max of two options\n\n    return dp[0][n - 1]  # Return the length of the longest palindromic subsequence\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "\ndef is_woodall(number):\n    # Iterate through possible starting points for the sum\n    for start in range(1, number + 1):\n        sum = 0\n        # Calculate the sum of consecutive integers starting from 'start'\n        for n in range(start, number + 1):\n            sum += n\n            # Check if the current sum equals the given number\n            if sum == number:\n                return True\n            # If the sum exceeds the number, break out of the loop\n            if sum > number:\n                break\n    # If no combination matched, return False\n    return False\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[254]], "plus_fail_tests": [[123456789]]}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "\ndef sum_of_proper_divisors(n):\n    # This function calculates the sum of proper divisors of n\n    total = 0\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            total += i\n    return total\n\ndef amicable_numbers_sum(limit):\n    # This function finds all amicable numbers up to the specified limit and returns their sum\n    amicable_numbers = set()  # Use a set to avoid duplicates\n    for num in range(1, limit + 1):\n        partner = sum_of_proper_divisors(num)  # Find the sum of proper divisors\n        # Check if the partner is different and forms an amicable pair\n        if partner != num and sum_of_proper_divisors(partner) == num:\n            amicable_numbers.add(num)  # Add the first number\n            amicable_numbers.add(partner)  # Add the partner number\n    return sum(amicable_numbers)  # Return the sum of all unique amicable numbers\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9999]], "plus_fail_tests": [[10000]]}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "\ndef count_sequences(current_value, current_length, m, n):\n    # Base case: if the current length equals n, we found a valid sequence\n    if current_length == n:\n        return 1\n    \n    count = 0\n    # Calculate the next possible value which is at least double the current value\n    next_value = 2 * current_value\n    \n    # Loop to find all valid next values that are less than or equal to m\n    while next_value <= m:\n        # Recursively count sequences starting from the next value\n        count += count_sequences(next_value, current_length + 1, m, n)\n        next_value += 1  # Increment to check the next possible value\n    \n    return count\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    total_count = 0\n    # Start the sequence with each possible starting value from 1 to m\n    for starting_value in range(1, m + 1):\n        total_count += count_sequences(starting_value, 1, m, n)\n    return total_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[200, 100]]}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "\n# Define a function that takes two numbers as input\ndef swap_numbers(num1, num2):\n    # Create a tuple with the second number first and the first number second\n    result = (num2, num1)\n    # Return the created tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "\ndef maximize_elements(tuple1, tuple2):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through both tuples simultaneously\n    for (a, b), (c, d) in zip(tuple1, tuple2):\n        # Find the maximum of the first elements\n        max_first = max(a, c)\n        # Find the maximum of the second elements\n        max_second = max(b, d)\n        # Create a new pair with these maximums\n        result.append((max_first, max_second))\n    \n    # Convert the result list to a tuple\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "\ndef split_two_parts(lst, L):\n    # Get the first part of the list containing the first L elements\n    first_part = lst[0:L]\n    # Get the second part of the list containing the elements from index L to the end\n    second_part = lst[L:]\n    # Return both parts as a tuple\n    return (first_part, second_part)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "\n# Define a function to calculate dog's age in dog's years\ndef dog_age(human_years: int) -> int:\n    # If the dog's age is 2 years or less\n    if human_years <= 2:\n        # Calculate dog's age as 10.5 years for each human year\n        return int(human_years * 10.5)\n    else:\n        # Calculate the age for the first two years\n        # and add 4 for each additional year\n        return 21 + (human_years - 2) * 4\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "\ndef is_prime(num):\n    # Check if the number is less than or equal to 1\n    if num <= 1:\n        return False\n    # Check for factors from 2 to the square root of num\n    for j in range(2, int(num**0.5) + 1):\n        if num % j == 0:\n            return False\n    return True\n\ndef count_Primes_nums(n: int) -> int:\n    # If n is less than or equal to 2, there are no primes less than n\n    if n <= 2:\n        return 0\n    count = 0\n    # Iterate through all numbers from 2 to n-1\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1  # Increment count if i is prime\n    return count  # Return the total count of prime numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "\n# Define a function to calculate the lateral surface area of a cube\ndef lateralsurface_cube(side_length):\n    # Check if the side length is valid (greater than 0)\n    if side_length <= 0:\n        return 0  # Return 0 for non-positive side lengths\n    # Calculate the lateral surface area using the formula\n    lateral_surface_area = 4 * (side_length * side_length)\n    return lateral_surface_area  # Return the calculated area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "\ndef square_Sum(n):\n    # Initialize the sum of squares\n    sum_of_squares = 0\n    # Loop through the first n odd natural numbers\n    for i in range(n):\n        # Calculate the ith odd number\n        odd_number = 2 * i + 1\n        # Add the square of the odd number to the sum\n        sum_of_squares += odd_number * odd_number\n    # Return the total sum of squares\n    return sum_of_squares\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "\ndef list_split(input_list, n):\n    # Create an empty list to hold the resulting lists\n    result = []\n    \n    # Iterate over the range from 0 to n-1\n    for i in range(n):\n        # Create a temporary list to hold the current split\n        temp = []\n        \n        # Iterate through the input list starting from index i, stepping by n\n        for j in range(i, len(input_list), n):\n            # Append the current element to the temporary list\n            temp.append(input_list[j])\n        \n        # Append the temporary list to the result\n        result.append(temp)\n    \n    # Return the final list of lists\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "\ndef find_star_num(n):\n    # Calculate the n-th star number using the correct formula\n    return n * (3 * n - 2)  # This gives the correct star number\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "\ndef division_elements(tuple1, tuple2):\n    # Create an empty list to store results\n    results = []\n    \n    # Iterate through the elements of both tuples simultaneously\n    for i in range(len(tuple1)):\n        # Divide the element of the first tuple by the element of the second tuple\n        result = tuple1[i] // tuple2[i]  # Using integer division\n        # Append the result to the results list\n        results.append(result)\n    \n    # Convert results list to a tuple\n    return tuple(results)\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 3, 3], [5, 2, 3, 4]]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "\n# Define a function that takes a single character as input\ndef ascii_value(character: str) -> int:\n    # Use the built-in ord() function to get the ASCII value of the character\n    return ord(character)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "\ndef sum_even_and_even_index(numbers):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through the list with index\n    for index in range(len(numbers)):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Check if the number at that index is even\n            if numbers[index] % 2 == 0:\n                # Add the even number at even index to the total sum\n                total_sum += numbers[index]\n    \n    # Return the total sum of even numbers at even indices\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "\ndef rear_extract(tuples_list):\n    # Create an empty list to store the last elements\n    result = []\n    # Iterate through each tuple in the input list\n    for tup in tuples_list:\n        # Get the last element of the tuple using negative indexing\n        last_element = tup[-1]\n        # Append the last element to the result list\n        result.append(last_element)\n    # Return the list containing the last elements of each tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "\ndef substract_elements(tuple1, tuple2):\n    # Create an empty list to store the results\n    result = []\n    \n    # Loop through the indices of the tuples\n    for index in range(len(tuple1)):\n        # Subtract the element of the second tuple from the first\n        difference = tuple1[index] - tuple2[index]\n        # Append the result to the list\n        result.append(difference)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "\n# Define a function to calculate the volume of a cylinder\ndef volume_cylinder(radius, height):\n    # Set the value of pi\n    pi = 3.141592653589793\n    # Calculate the volume using the formula V = \u03c0 * r\u00b2 * h\n    volume = pi * (radius ** 2) * height\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "\ndef factorial(num):\n    # Helper function to calculate factorial of a number\n    if num == 0 or num == 1:\n        return 1\n    result = 1\n    for i in range(2, num + 1):\n        result *= i\n    return result\n\ndef binomial_coefficient(n, k):\n    # Helper function to calculate binomial coefficient C(n, k)\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    # Function to calculate the sum of even index binomial coefficients\n    sum_even_coeffs = 0\n    for k in range(0, n + 1):\n        if k % 2 == 0:  # Check if k is even\n            sum_even_coeffs += binomial_coefficient(n, k)  # Add C(n, k) to the sum\n    return sum_even_coeffs  # Return the final sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "\ndef dict_filter(input_dict, n):\n    # Create an empty dictionary to store filtered results\n    filtered_dict = {}\n    \n    # Iterate through each key-value pair in the input dictionary\n    for key, value in input_dict.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n            \n    # Return the filtered dictionary\n    return filtered_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "\ndef count_first_elements(input_tuple):\n    # Initialize a counter to keep track of the number of elements\n    count = 0\n    \n    # Iterate through each element in the input tuple\n    for element in input_tuple:\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # If it is a tuple, return the current count\n            return count\n        # Increment the count for each non-tuple element\n        count += 1\n    \n    # If no tuple is found, return the count (though this case shouldn't happen as per the problem statement)\n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "\n# Function to calculate the nth decagonal number\ndef is_num_decagonal(n):\n    # Check if n is a valid positive integer\n    if n < 1:\n        return None  # or raise an error for invalid input\n    # Calculate the nth decagonal number using the formula\n    decagonal_number = 4 * n * n - 3 * n\n    return decagonal_number  # Return the calculated decagonal number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "\ndef sequential_search(array, element):\n    # Iterate through the array using index\n    for index in range(len(array)):\n        # Check if the current element matches the target element\n        if array[index] == element:\n            # If found, return True and the index\n            return (True, index)\n    # If not found, return False and -1\n    return (False, -1)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "\ndef all_unique(input_list):\n    # Create an empty set to keep track of seen elements\n    seen = set()\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # If the element is already in the seen set, return False\n        if element in seen:\n            return False\n        # Add the element to the seen set\n        seen.add(element)\n    \n    # If no duplicates were found, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "\ndef sub_list(list1, list2):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Subtract the corresponding elements and append to the result list\n        result.append(list1[i] - list2[i])\n    # Return the final result list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "\ndef validate(n: int) -> bool:\n    # Convert the integer to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Create a dictionary to count the frequency of each digit\n    frequency = {}\n    \n    # Count the frequency of each digit\n    for char in str_n:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in frequency.items():\n        if count > int(digit):\n            return False\n    \n    # If all checks pass, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "\n# Define a function that checks if all items in the list are equal to the given element\ndef check_element(lst, element):\n    # Iterate through each item in the list\n    for item in lst:\n        # If any item is not equal to the specified element, return False\n        if item != element:\n            return False\n    # If all items are equal to the specified element, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "\ndef text_match_two_three(s: str) -> bool:\n    # Iterate through each character in the string\n    for i in range(len(s)):\n        # Check if the current character is 'a'\n        if s[i] == 'a':\n            # Check for two 'b's following 'a'\n            if i + 2 < len(s) and s[i + 1] == 'b' and s[i + 2] == 'b':\n                return True\n            # Check for three 'b's following 'a'\n            if i + 3 < len(s) and s[i + 1] == 'b' and s[i + 2] == 'b' and s[i + 3] == 'b':\n                return True\n    # Return False if the pattern is not found\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "\ndef max_sub_array_sum(arr):\n    # Initialize current and global maximums\n    current_max = arr[0]\n    global_max = arr[0]\n    \n    # Iterate through the array to find the maximum subarray sum\n    for number in arr[1:]:\n        current_max = max(number, current_max + number)  # Update current max\n        global_max = max(global_max, current_max)  # Update global max if needed\n    \n    return global_max\n\ndef max_sub_array_sum_repeated(arr, n, k):\n    # Handle edge case where k is 0\n    if k == 0:\n        return 0\n    # If k is 1, just find the max subarray sum of the original array\n    if k == 1:\n        return max_sub_array_sum(arr)\n    \n    # Calculate the maximum subarray sum of the original array\n    max_sum = max_sub_array_sum(arr)\n    # Calculate the total sum of the original array\n    total_sum = sum(arr)\n    \n    # If the total sum is positive, consider the contribution of additional full arrays\n    if total_sum > 0:\n        max_sum = max(max_sum, max_sub_array_sum(arr + arr) + (k - 2) * total_sum)\n    else:\n        # If total sum is not positive, just consider the max subarray sum of the doubled array\n        max_sum = max(max_sum, max_sub_array_sum(arr + arr))\n    \n    return max_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "\ndef max_length(lists):\n    # Initialize the maximum length to 0\n    max_length = 0\n    # Initialize the longest list to an empty list\n    longest_list = []\n    \n    # Iterate through each sublist in the input list of lists\n    for sublist in lists:\n        # Check if the current sublist's length is greater than the max_length found so far\n        if len(sublist) > max_length:\n            # Update max_length to the length of the current sublist\n            max_length = len(sublist)\n            # Update longest_list to the current sublist\n            longest_list = sublist\n    \n    # Return a tuple containing the maximum length and the longest list\n    return (max_length, longest_list)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "\n# Define a function to find the quotient of two numbers\ndef find(a: int, b: int) -> int:\n    # Use integer division to get the quotient rounded down\n    return a // b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "\nimport math\n\ndef otherside_rightangle(side1: float, side2: float) -> float:\n    # Calculate the hypotenuse using the Pythagorean theorem\n    hypotenuse = math.sqrt(side1**2 + side2**2)\n    return hypotenuse\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "\ndef square_Sum(n):\n    # Initialize a variable to hold the sum of squares\n    sum_of_squares = 0\n    \n    # Loop through the first n even natural numbers\n    for k in range(1, n + 1):\n        # Calculate the k-th even natural number\n        even_number = 2 * k\n        \n        # Calculate the square of the even number\n        square = even_number * even_number\n        \n        # Add the square to the sum of squares\n        sum_of_squares += square\n    \n    # Return the total sum of squares\n    return sum_of_squares\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "\ndef max_val(input_list):\n    # Initialize max_value to None to track the maximum number found\n    max_value = None\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # Check if the element is a number (int or float)\n        if isinstance(element, (int, float)):\n            # If max_value is None or the current element is greater than max_value\n            if max_value is None or element > max_value:\n                # Update max_value to the current element\n                max_value = element\n    \n    # Return the maximum value found\n    return max_value\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["3.14", false, 7.5]]]}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # Count inversions\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)  # Create a temporary array\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "\ndef flatten_list(nested_list):\n    # Create an empty list to hold the flattened result\n    flat_list = []\n    \n    # Iterate through each element in the provided nested list\n    for element in nested_list:\n        # Check if the current element is a list\n        if isinstance(element, list):\n            # If it is a list, recursively flatten it and extend the flat_list with the result\n            flat_list.extend(flatten_list(element))\n        else:\n            # If it is not a list, append the element to flat_list\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "\ndef max_aggregate(tuples):\n    # Create an empty dictionary to store total scores for each name\n    score_dict = {}\n    \n    # Iterate through each tuple in the list\n    for name, score in tuples:\n        # If the name is not in the dictionary, add it with the score\n        if name not in score_dict:\n            score_dict[name] = score\n        else:\n            # If the name is already in the dictionary, add the score to the existing total\n            score_dict[name] += score\n    \n    # Initialize variables to track the maximum score and corresponding name\n    max_name = None\n    max_score = 0\n    \n    # Iterate through the dictionary to find the name with the maximum score\n    for name, score in score_dict.items():\n        if score > max_score:\n            max_name = name\n            max_score = score\n    \n    # Return the name with the maximum score and the score itself\n    return (max_name, max_score)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[["Alice", -50]]]]}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "\ndef is_not_prime(n):\n    # Check if the number is less than 2\n    if n < 2:\n        return True  # 0 and 1 are not prime numbers\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is not prime\n    return False  # No divisors found, so n is prime\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "\ndef dict_depth(d):\n    # Check if the input is a dictionary\n    if not isinstance(d, dict):\n        return 0  # If not, return 0 depth\n    \n    max_depth = 0  # Initialize maximum depth\n    \n    # Iterate through each key-value pair in the dictionary\n    for value in d.values():\n        if isinstance(value, dict):  # If the value is a dictionary\n            # Recursively find the depth of the nested dictionary\n            depth = dict_depth(value)\n            # Update max_depth if the found depth is greater\n            if depth > max_depth:\n                max_depth = depth\n    \n    return max_depth + 1  # Return the maximum depth found plus one for the current level\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "\ndef start_withp(words):\n    # Initialize an empty list to hold words starting with 'p' or 'P'\n    p_words = []\n    \n    # Iterate through each string in the input list\n    for string in words:\n        # Split the string into individual words\n        for word in string.split():\n            # Check if the word starts with 'p' or 'P'\n            if word.startswith('p') or word.startswith('P'):\n                # Add the word to the list\n                p_words.append(word)\n                # If we have collected two words, return them as a tuple\n                if len(p_words) == 2:\n                    return (p_words[0], p_words[1])\n    \n    # Return the collected words as a tuple (may be less than two)\n    return tuple(p_words)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a list to store the maximum sum of increasing subsequences\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a variable to store the maximum sum\n    max_sum = 0\n    \n    # Iterate through all elements from 0 to i\n    for j in range(i):\n        # Start a new subsequence with arr[j]\n        current_sum = arr[j]\n        last_included = arr[j]\n        \n        # Check for increasing elements after arr[j]\n        for m in range(j + 1, i):\n            if arr[m] > last_included:\n                current_sum += arr[m]\n                last_included = arr[m]\n        \n        # Add the value at index k to the current sum\n        current_sum += arr[k]\n        \n        # Update max_sum if the current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    # List to hold the Newman\u2013Shanks\u2013Williams primes\n    newman_primes = []\n    # Number to check for primality\n    num = 2\n    \n    # Loop until we find the nth newman prime\n    while len(newman_primes) < n:\n        # Check if the number is prime\n        if is_prime(num):\n            # Check if it is a Newman\u2013Shanks\u2013Williams prime\n            if num in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]:  # Known Newman\u2013Shanks\u2013Williams primes\n                newman_primes.append(num)\n        # Move to the next number\n        num += 1\n    \n    # Return the nth newman prime\n    return newman_primes[n - 1]\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "\ndef large_product(list1, list2, n):\n    # Create an empty list to store the products\n    products = []\n    \n    # Iterate through each number in the first list\n    for num1 in list1:\n        # Iterate through each number in the second list\n        for num2 in list2:\n            # Calculate the product of the two numbers\n            product = num1 * num2\n            # Add the product to the products list\n            products.append(product)\n    \n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n elements of the sorted products list\n    return products[:n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "\ndef binomial_coefficient(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    if k > n or k < 0:\n        return 0\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)  # Use integer division\n    return result\n\ndef count_binary_seq(n: int) -> float:\n    # Initialize total count of valid binary sequences\n    total_count = 0\n    # Iterate over all possible sums of the first half\n    for k in range(n + 1):\n        # Calculate the number of ways to choose k 1's from n bits\n        count_k = binomial_coefficient(n, k)\n        # Add the square of count_k to total_count\n        total_count += count_k * count_k\n    # Return the total count as a float\n    return float(total_count)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "\n# Define a function named maximum that takes two parameters\ndef maximum(a, b):\n    # Compare the two numbers\n    if a > b:\n        # If the first number is greater, return it\n        return a\n    else:\n        # Otherwise, return the second number\n        return b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "\ndef string_to_tuple(s: str) -> tuple:\n    # Create a list of characters excluding spaces\n    filtered_chars = [char for char in s if char != ' ']\n    # Convert the list to a tuple and return it\n    return tuple(filtered_chars)\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\t"]]}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "\ndef set_left_most_unset_bit(n: int) -> int:\n    # Convert the number to binary and remove the '0b' prefix\n    binary_str = bin(n)[2:]\n    \n    # Find the leftmost '0' and replace it with '1'\n    modified_binary_str = ''\n    found_zero = False\n    \n    for bit in binary_str:\n        if bit == '0' and not found_zero:\n            modified_binary_str += '1'  # Set the leftmost unset bit\n            found_zero = True\n        else:\n            modified_binary_str += bit  # Keep the rest the same\n    \n    # If no zero was found, we need to add a '1' at the end\n    if not found_zero:\n        modified_binary_str += '1'\n    \n    # Convert the modified binary string back to an integer\n    new_integer = int(modified_binary_str, 2)\n    return new_integer\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15]], "plus_fail_tests": [[255]]}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "\nimport math\n\n# Function to calculate the volume of a cone\ndef volume_cone(radius: float, height: float) -> float:\n    # Calculate the volume using the formula for the volume of a cone\n    volume = (1/3) * math.pi * (radius ** 2) * height\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "\ndef highest_Power_of_2(n):\n    # Initialize the variable to hold the current power of 2\n    power = 1\n    \n    # Keep doubling the power until it exceeds n\n    while power * 2 <= n:\n        power = power * 2\n    \n    # Return the highest power of 2 found\n    return power\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "\ndef find_lucas(n):\n    # Base case for the 0th Lucas number\n    if n == 0:\n        return 2\n    # Base case for the 1st Lucas number\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    first = 2  # L(0)\n    second = 1  # L(1)\n    \n    # Calculate the n-th Lucas number iteratively\n    for i in range(2, n + 1):\n        next = first + second  # L(n) = L(n-1) + L(n-2)\n        first = second  # Move to the next number in the sequence\n        second = next  # Update the second number to the new calculated value\n    \n    return second  # Return the n-th Lucas number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "\ndef convert_list_dictionary(ids, names, scores):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through the indices of the input lists\n    for i in range(len(ids)):\n        # Create a dictionary for each student\n        student_dict = {ids[i]: {names[i]: scores[i]}}\n        # Add the student dictionary to the result list\n        result.append(student_dict)\n    \n    # Return the final list of dictionaries\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [[1, 2, 3], [4, 5, 6], {"a": "x", "b": "y", "c": "z"}]]]}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "\ndef add_string(numbers, format_string):\n    # Create an empty list to hold the results\n    result = []\n    \n    # Iterate over each number in the input list\n    for number in numbers:\n        # Format the string by replacing the placeholder with the current number\n        formatted_string = format_string.format(number)\n        \n        # Append the formatted string to the result list\n        result.append(formatted_string)\n    \n    # Return the list of formatted strings\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "\n# Initialize a dictionary to store previously computed results\nmemo = {}\n\ndef get_max_sum(n: int) -> int:\n    # Base case: if n is 0, the maximum sum is also 0\n    if n == 0:\n        return 0\n    # Check if the result for n is already computed\n    if n in memo:\n        return memo[n]\n    # Recursively calculate the maximum sums for n/2, n/3, n/4, and n/5\n    sum_parts = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    # Store the maximum of the calculated sum or n itself in the memo dictionary\n    memo[n] = max(sum_parts, n)\n    # Return the computed maximum sum for n\n    return memo[n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "\ndef check_distinct(tup):\n    # Create an empty set to keep track of seen elements\n    seen = set()\n    \n    # Iterate through each element in the tuple\n    for element in tup:\n        # If the element is already in the seen set, return False\n        if element in seen:\n            return False\n        # Add the element to the seen set\n        seen.add(element)\n    \n    # If no duplicates were found, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "\ndef first_non_repeating_character(s: str) -> str:\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "\ndef sum_of_digits(numbers):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Convert the number to a string to access each digit\n        digit_sum = 0\n        for digit in str(number):\n            # Convert each character back to an integer and sum them\n            digit_sum += int(digit)\n        \n        # Add the sum of the digits of the current number to the total sum\n        total_sum += digit_sum\n    \n    # Return the total sum of all digit sums\n    return total_sum\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "\ndef median_numbers(a: float, b: float, c: float) -> float:\n    # Create a list of the three numbers\n    numbers = [a, b, c]\n    # Sort the list of numbers\n    numbers.sort()\n    # Return the second element, which is the median\n    return numbers[1]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "\ndef heap_queue_largest(numbers, n):\n    # Step 1: Sort the list of numbers in descending order\n    sorted_numbers = sorted(numbers, reverse=True)\n    \n    # Step 2: Select the first n elements from the sorted list\n    largest_numbers = sorted_numbers[:n]\n    \n    # Step 3: Return the selected elements\n    return largest_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "\n# Define a function to check if an element exists in a tuple\ndef check_tuplex(tup, elem):\n    # Use the 'in' keyword to check for the presence of the element in the tuple\n    return elem in tup\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "\n# Define a function to find the minimum of two numbers\ndef minimum(a, b):\n    # Check if the first number is less than or equal to the second\n    if a <= b:\n        # If true, return the first number\n        return a\n    else:\n        # Otherwise, return the second number\n        return b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "\n# Define a function to find the parity of a number\ndef find_Parity(number):\n    # Check if the number is odd\n    if number % 2 == 1:\n        return True  # Return True if the number is odd\n    else:\n        return False  # Return False if the number is even\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "\ndef min_product_tuple(tuples):\n    # Initialize min_product to a very large number\n    min_product = float('inf')\n    \n    # Loop through each tuple in the list\n    for tup in tuples:\n        # Calculate the product of the two integers in the tuple\n        product = tup[0] * tup[1]\n        \n        # If the product is less than the current minimum product, update it\n        if product < min_product:\n            min_product = product\n            \n    # Return the minimum product found\n    return min_product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "\ndef is_number(value):\n    # Check if the value is an integer or a float\n    return isinstance(value, (int, float))\n\ndef min_val(input_list):\n    # Initialize min_value to None\n    min_value = None\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # Check if the element is a number\n        if is_number(element):\n            # If min_value is None or the current element is less than min_value\n            if min_value is None or element < min_value:\n                # Update min_value to the current element\n                min_value = element\n                \n    # Return the minimum value found\n    return min_value\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "\ndef remove_odd(numbers):\n    # Create an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If it is even, add it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "\ndef extract_nth_element(tuples_list, n):\n    # Create an empty list to store the nth elements\n    result = []\n    # Iterate through each tuple in the provided list\n    for tuple in tuples_list:\n        # Append the nth element of the tuple to the result list\n        result.append(tuple[n])\n    # Return the list of nth elements\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "\n# Define a helper function to check if an element exists in a sequence\ndef exists_in_sequence(element, sequence):\n    for item in sequence:\n        if item == element:\n            return True\n    return False\n\n# Main function to check for overlapping values\ndef overlapping(seq1, seq2):\n    # Iterate through each element in the first sequence\n    for element in seq1:\n        # Check if the current element exists in the second sequence\n        if exists_in_sequence(element, seq2):\n            return True  # Return True if a match is found\n    return False  # Return False if no matches are found\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "\ndef max_Product(arr):\n    # Check if the array has fewer than 2 elements\n    if len(arr) < 2:\n        return None  # or handle the case as needed\n    \n    # Initialize the two largest numbers and their indices\n    first_max = float('-inf')\n    second_max = float('-inf')\n    first_index = -1\n    second_index = -1\n    \n    # Iterate through the array to find the two largest numbers and their indices\n    for index, number in enumerate(arr):\n        if number > first_max:\n            # Update second_max before updating first_max\n            second_max = first_max\n            second_index = first_index\n            first_max = number\n            first_index = index\n        elif number > second_max:\n            # Update second_max if number is less than first_max but greater than second_max\n            second_max = number\n            second_index = index\n    \n    # Return the two largest numbers as a tuple in the order they appear in the list\n    if first_index < second_index:\n        return (first_max, second_max)\n    else:\n        return (second_max, first_max)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0, -1, -2, -4, 5, 0, -6]]], "plus_fail_tests": [[[10, -20, 30, -40, 50, -60, 70, -80, 90, -100]]]}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "\ndef Find_Max(list_of_lists):\n    # Initialize the maximum length and the corresponding sublist\n    max_length = 0\n    max_list = None\n    \n    # Iterate through each sublist in the input list\n    for sublist in list_of_lists:\n        # Check if the current sublist is longer than the max_length found so far\n        if len(sublist) > max_length:\n            # Update max_length and max_list with the current sublist\n            max_length = len(sublist)\n            max_list = sublist\n            \n    # Return the sublist with the maximum length\n    return max_list\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[], [], []]]]}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "\ndef round_and_sum(numbers):\n    # Initialize total_sum to 0\n    total_sum = 0\n    \n    # Loop through each number in the list\n    for number in numbers:\n        # Round the number to the nearest integer\n        rounded_number = round(number)\n        # Add the rounded number to total_sum\n        total_sum += rounded_number\n    \n    # Multiply the total sum by the length of the list\n    result = total_sum * len(numbers)\n    \n    # Return the final result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "\ndef cube_Sum(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even natural number\n        even_number = 2 * i\n        # Calculate the cube of the even number\n        cube = even_number * even_number * even_number\n        # Add the cube to the total sum\n        total_sum += cube\n    # Return the final sum of cubes\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "\ndef concatenate_tuple(input_tuple):\n    # Convert each element of the tuple to a string\n    string_elements = [str(element) for element in input_tuple]\n    # Join the string elements with \"-\" as the delimiter\n    result = \"-\".join(string_elements)\n    # Return the concatenated string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "\ndef find_Average_Of_Cube(n):\n    # Initialize a variable to hold the sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Calculate the cube of the current number and add it to the sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate the average by dividing the sum of cubes by n\n    average = sum_of_cubes / n\n    \n    # Return the calculated average\n    return average\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "\ndef extract_rear(strings: tuple) -> list:\n    # Initialize an empty list to hold the last characters\n    last_characters = []\n    \n    # Iterate through each string in the input tuple\n    for string in strings:\n        # Get the last character of the string\n        last_character = string[-1]\n        # Append the last character to the list\n        last_characters.append(last_character)\n    \n    # Return the list of last characters\n    return last_characters\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "\ndef count_element_in_list(sublists, element):\n    # Initialize a counter to keep track of the number of sublists containing the element\n    count = 0\n    \n    # Iterate through each sublist in the provided list of sublists\n    for sublist in sublists:\n        # Check if the specified element is present in the current sublist\n        if element in sublist:\n            # If it is, increment the count\n            count += 1\n            \n    # Return the total count of sublists containing the element\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "\ndef filter_oddnumbers(input_list):\n    # Create an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # If it is odd, add it to the odd_numbers list\n            odd_numbers.append(number)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "\ndef and_tuples(tuple1, tuple2):\n    # Create an empty list to store the results\n    results = []\n    \n    # Iterate through the indices of the tuples\n    for i in range(len(tuple1)):\n        # Calculate the difference and apply the logic\n        difference = tuple1[i] - tuple2[i]\n        # Append the result of the difference to the results list\n        results.append(max(0, difference))\n    \n    # Convert the results list to a tuple and return it\n    return tuple(results)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 4, 6, 9], [5, 2, 3, 3]]], "plus_fail_tests": [[[123, 456, 789, 10], [987, 654, 321, 10]]]}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "\ndef change_date_format(date_str: str) -> str:\n    # Split the input date string by the hyphen\n    components = date_str.split('-')\n    \n    # Rearrange the components to the new format (day-month-year)\n    new_format = [components[2], components[1], components[0]]\n    \n    # Join the new format components with hyphens\n    formatted_date = '-'.join(new_format)\n    \n    # Return the newly formatted date string\n    return formatted_date\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "\ndef shell_sort(arr):\n    n = len(arr)  # Get the length of the array\n    gap = n // 2  # Start with a big gap, then reduce the gap\n    while gap > 0:  # Continue until the gap is reduced to zero\n        for i in range(gap, n):  # Start from the gap to the end of the array\n            temp = arr[i]  # Store the current element\n            j = i  # Initialize j to the current index\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]  # Move the element at j-gap to position j\n                j -= gap  # Move j back by the gap\n            arr[j] = temp  # Place the stored element in its correct position\n        gap //= 2  # Reduce the gap for the next iteration\n    return arr  # Return the sorted array\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    # Calculate the discriminant\n    D = b**2 - 4 * a * c\n    # Calculate the directrix using the correct formula\n    directrix = -D / (4 * a) + (1 / (4 * a))\n    # Return the directrix value as an integer\n    return int(directrix)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "\n# Define a function to calculate the median length of a trapezium\ndef median_trapezium(base1: int, base2: int, height: int) -> float:\n    # Calculate the median length by averaging the two bases\n    median_length = (base1 + base2) / 2\n    # Return the calculated median length\n    return median_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "\ndef remove_odd(input_string: str) -> str:\n    # Create an empty string to store the result\n    result = \"\"\n    # Iterate through the input string using its indices\n    for index in range(len(input_string)):\n        # Check if the index is odd\n        if index % 2 == 1:\n            # Append the character at the odd index to the result\n            result += input_string[index]\n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "\n# Define a function to find the last digit of a given number\ndef last_Digit(number):\n    # Use the modulus operator to get the last digit\n    return number % 10\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-987]]}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "\ndef neg_nos(input_list):\n    # Create an empty list to store negative numbers\n    negative_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the list\n            negative_numbers.append(number)\n    \n    # Return the list of negative numbers\n    return negative_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "\ndef multiple_to_single(integers):\n    # Initialize an empty string to hold the concatenated result\n    result = \"\"\n    \n    # Iterate through each integer in the input list\n    for integer in integers:\n        # Convert the integer to a string and append it to the result\n        result += str(integer)\n    \n    # Convert the concatenated string back to an integer\n    return int(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "\ndef check_greater(array, number):\n    # Iterate through each element in the provided array\n    for element in array:\n        # Check if the current element is greater than or equal to the number\n        if element >= number:\n            # If it is, return False\n            return False\n    # If no elements were greater than or equal to the number, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "\ndef find_adverb_position(sentence: str) -> tuple:\n    # Define a list of common adverbs\n    adverbs = [\"clearly\", \"quickly\", \"silently\", \"happily\", \"sadly\", \"eagerly\", \"very\", \"too\", \"well\", \"badly\"]\n    \n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Iterate through the words to find the first adverb\n    for word in words:\n        # Strip punctuation from the word for comparison\n        stripped_word = ''.join(char for char in word if char.isalnum())\n        if stripped_word in adverbs:\n            # Calculate the start index of the word in the sentence\n            start_index = sentence.index(word)\n            # Calculate the end index of the adverb in the sentence\n            end_index = start_index + len(stripped_word) - 1\n            # Return the indices and the adverb\n            return (start_index, end_index, stripped_word)\n    \n    # Return None if no adverb is found\n    return None\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["clearly!! we can see the sky"]], "plus_fail_tests": [["heavily and quickly we ran down the steep hill"]]}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "\n# Define a function to calculate the surface area of a cube\ndef surfacearea_cube(side_length):\n    # Calculate the area of one face of the cube\n    area_of_one_face = side_length * side_length\n    # Calculate the total surface area (6 faces)\n    surface_area = 6 * area_of_one_face\n    # Return the calculated surface area\n    return surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "\ndef cal_sum(n: int) -> int:\n    # Handle the base cases for n = 0, 1, and 2\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    \n    # Initialize the first three Perrin numbers\n    P0, P1, P2 = 3, 0, 2\n    total_sum = P0 + P1 + P2  # Start the sum with the first three numbers\n    \n    # Calculate Perrin numbers from P(3) to P(n) and sum them\n    for i in range(3, n + 1):\n        Pn = P0 + P1  # P(n) = P(n-2) + P(n-3)\n        total_sum += Pn  # Add the current Perrin number to the sum\n        \n        # Update the previous Perrin numbers for the next iteration\n        P0, P1, P2 = P1, P2, Pn\n    \n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "\ndef count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count how many times the element appears in the tuple and add to count\n        count += tup.count(element)\n    \n    # Return the total count of occurrences\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "\ndef index_multiplication(tuple1, tuple2):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate through both tuples using their indices\n    for i in range(len(tuple1)):\n        # Multiply the elements at the same index\n        product = (tuple1[i][0] * tuple2[i][0], tuple1[i][1] * tuple2[i][1])\n        # Append the product to the results list\n        result.append(product)\n    \n    # Convert the results list to a tuple\n    return tuple(result)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10]]]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "\ndef cube_nums(input_list):\n    # Create an empty list to store the results\n    result = []\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # Calculate the cube of the number\n        cube = number * number * number\n        # Append the cube to the result list\n        result.append(cube)\n    \n    # Return the list of cubes\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2.5, 3, -4.7, 5, 6, 7, -8.9]]]}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "\ndef extract_string(string_list, length):\n    # Create an empty list to store the results\n    result = []\n    # Iterate through each string in the provided list\n    for string in string_list:\n        # Check if the length of the string is equal to the specified length\n        if len(string) == length:\n            # If it is, add the string to the result list\n            result.append(string)\n    # Return the list of strings that match the specified length\n    return result\n\n# The function can be called with the example provided:\n# extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "\ndef remove_whitespaces(input_string: str) -> str:\n    # Create an empty string to hold the result\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is not a whitespace\n        if char != ' ':\n            # Append the non-whitespace character to the result\n            result += char\n            \n    # Return the result string with all whitespaces removed\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "\n# Define the function that checks for the presence of 'z' in the input string\ndef text_match_wordz(word: str) -> bool:\n    # Check if 'z' is in the provided word\n    if 'z' in word:\n        return True  # Return True if 'z' is found\n    else:\n        return False  # Return False if 'z' is not found\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "\ndef reverse_string_list(input_list):\n    # Create an empty list to hold the reversed strings\n    reversed_list = []\n    \n    # Iterate through each string in the input list\n    for string in input_list:\n        # Reverse the string and add it to the reversed_list\n        reversed_list.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "\ndef check_monthnumb_number(month: int) -> bool:\n    # List of months that have 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month is in the list\n    return month in months_with_31_days\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "\ndef Find_Min(sublists):\n    # Initialize the shortest sublist with the first sublist\n    shortest_sublist = sublists[0]\n    \n    # Iterate through each sublist in the provided list\n    for sublist in sublists:\n        # If the current sublist is shorter than the shortest found so far\n        if len(sublist) < len(shortest_sublist):\n            # Update the shortest sublist\n            shortest_sublist = sublist\n            \n    # Return the shortest sublist found\n    return shortest_sublist\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "\n# Define a function to calculate the area of a rectangle\ndef rectangle_area(width: int, height: int) -> int:\n    # Calculate the area by multiplying width and height\n    area = width * height\n    # Return the calculated area\n    return area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "\ndef remove_uppercase(input_string: str) -> str:\n    # Create an empty string to store the result\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is not uppercase\n        if not char.isupper():\n            # Append the character to the result string\n            result += char\n            \n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "\ndef Extract(input_list):\n    # Initialize an empty list to store the first elements\n    result = []\n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Check if the sublist is not empty\n        if sublist:\n            # Append the first element of the sublist to the result list\n            result.append(sublist[0])\n    # Return the list of first elements\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "\ndef max_subarray_product(arr):\n    # Check if the array is empty\n    if not arr:\n        return 0\n    \n    # Initialize max_product, min_product, and result with the first element\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        number = arr[i]\n        \n        # If the current number is negative, swap max_product and min_product\n        if number < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update max_product and min_product\n        max_product = max(number, max_product * number)\n        min_product = min(number, min_product * number)\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "\ndef drop_empty(input_dict):\n    # Create an empty dictionary to store non-empty items\n    result = {}\n    \n    # Iterate through each key-value pair in the input dictionary\n    for key, value in input_dict.items():\n        # Check if the value is not None\n        if value is not None:\n            # Add the key-value pair to the result dictionary\n            result[key] = value\n            \n    # Return the dictionary containing only non-empty items\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "\ndef add_pairwise(input_tuple):\n    # Create an empty list to store the results\n    results = []\n    \n    # Iterate through the tuple up to the second-to-last element\n    for i in range(len(input_tuple) - 1):\n        # Calculate the sum of the current element and the next element\n        sum_pair = input_tuple[i] + input_tuple[i + 1]\n        # Append the sum to the results list\n        results.append(sum_pair)\n    \n    # Convert the results list to a tuple and return it\n    return tuple(results)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "\ndef max_product(arr):\n    # If the array is empty, return 0\n    if not arr:\n        return 0\n    \n    # Create a list to store the maximum products for increasing subsequences\n    max_products = [0] * len(arr)  # Initialize with 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        max_products[i] = arr[i]  # Start with the current element itself\n        # Check all previous elements to find increasing subsequences\n        for j in range(i):\n            if arr[j] < arr[i]:\n                # Update the maximum product for the current element\n                max_products[i] = max(max_products[i], max_products[j] * arr[i])\n    \n    # Return the maximum value found in max_products\n    return max(max_products)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[2, 3, 3, 4, 5, 3, 6]]]}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "\ndef find_remainder(array, n):\n    # Initialize the product variable to 1\n    product = 1\n    \n    # Loop through each number in the input array\n    for number in array:\n        # Multiply the current number to the product\n        product *= number\n    \n    # Return the product modulo n\n    return product % n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "\ndef check_Consecutive(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return False\n    \n    # Sort the list of numbers\n    numbers.sort()\n    \n    # Check for consecutive numbers\n    for i in range(1, len(numbers)):\n        # If the current number is not equal to the previous number + 1, return False\n        if numbers[i] != numbers[i - 1] + 1:\n            return False\n            \n    # If all checks passed, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "\ndef tuple_intersection(list1, list2):\n    # Create an empty set to store the result\n    result = set()\n    \n    # Iterate through each tuple in the first list\n    for tup1 in list1:\n        # Sort the first tuple and convert it to a frozenset for comparison\n        sorted_tup1 = frozenset(tup1)\n        \n        # Iterate through each tuple in the second list\n        for tup2 in list2:\n            # Sort the second tuple and convert it to a frozenset for comparison\n            sorted_tup2 = frozenset(tup2)\n            \n            # Check if the sorted frozensets are equal\n            if sorted_tup1 == sorted_tup2:\n                # If they are equal, add the original tuple from list1 to the result set\n                result.add(tup1)\n    \n    # Return the set of common tuples\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[4, 1], [7, 4], [11, 13], [17, 14]], [[1, 4], [7, 4], [16, 12], [10, 13]]]], "plus_fail_tests": [[[[2, 3, 1], [6, 5, 4], [11, 12, 10]], [[2, 3, 1], [6, 5, 4], [11, 12, 10]]]]}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "\ndef replace_char(input_string: str, char_to_replace: str, new_char: str) -> str:\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character matches the one to replace\n        if char == char_to_replace:\n            # Append the new character to the result list\n            result.append(new_char)\n        else:\n            # Append the original character to the result list\n            result.append(char)\n    \n    # Join the result list into a string and return it\n    return ''.join(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "\ndef sort_counter(input_dict):\n    # Convert the dictionary items to a list of tuples\n    items = list(input_dict.items())\n    \n    # Sort the list of tuples by the second element (value) in descending order\n    sorted_items = sorted(items, key=lambda x: x[1], reverse=True)\n    \n    # Return the sorted list\n    return sorted_items\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "\ndef big_sum(array):\n    # Check if the array is empty\n    if not array:\n        return 0\n    \n    # Initialize smallest and largest with the first element\n    smallest = array[0]\n    largest = array[0]\n    \n    # Iterate through each number in the array\n    for number in array:\n        # Update smallest if the current number is smaller\n        if number < smallest:\n            smallest = number\n        # Update largest if the current number is larger\n        if number > largest:\n            largest = number\n            \n    # Return the sum of the smallest and largest numbers\n    return smallest + largest\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "\ndef is_lower(s: str) -> str:\n    # Initialize an empty string to hold the result\n    result = \"\"\n    \n    # Loop through each character in the input string\n    for char in s:\n        # Check if the character is uppercase\n        if 'A' <= char <= 'Z':\n            # Convert to lowercase by adding 32 to its ASCII value\n            result += chr(ord(char) + 32)\n        else:\n            # Append the character as is\n            result += char\n            \n    # Return the result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "\ndef remove_lowercase(s: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Loop through each character in the input string\n    for char in s:\n        # Check if the character is not a lowercase letter\n        if not char.islower():\n            # Append the character to the result string\n            result += char\n            \n    # Return the result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "\ndef first_Digit(num: int) -> int:\n    # Convert the number to a string to access its digits\n    num_str = str(num)\n    # Get the first character of the string\n    first_char = num_str[0]\n    # Convert the first character back to an integer\n    first_digit = int(first_char)\n    # Return the first digit\n    return first_digit\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "\ndef difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = (n * (n + 1)) // 2\n    # Calculate the sum of the cubes of the first n natural numbers\n    sum_cubes = sum_n * sum_n\n    # Return the difference between the sum of cubes and the sum of the first n natural numbers\n    return sum_cubes - sum_n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "\ndef Split(input_list):\n    # Create an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # If it is odd, add it to the odd_numbers list\n            odd_numbers.append(number)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "\ndef find_Odd_Pair(arr, n):\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Loop through each number in the array\n    for num in arr:\n        # Check if the number is even\n        if num % 2 == 0:\n            even_count += 1  # Increment even counter\n        else:\n            odd_count += 1   # Increment odd counter\n    \n    # The number of pairs with odd XOR is the product of even and odd counts\n    return even_count * odd_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2], 10]]}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "\ndef toggle_string(input_string: str) -> str:\n    # Create an empty list to hold the toggled characters\n    toggled_chars = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Convert it to lowercase and add to the list\n            toggled_chars.append(char.lower())\n        # Check if the character is lowercase\n        elif char.islower():\n            # Convert it to uppercase and add to the list\n            toggled_chars.append(char.upper())\n        else:\n            # Add the character as is to the list (for non-alphabetic characters)\n            toggled_chars.append(char)\n    \n    # Join the list into a single string\n    return ''.join(toggled_chars)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "\ndef sumofFactors(n):\n    # Initialize the sum of even factors to 0\n    total_sum = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the total sum\n                total_sum += i\n                \n    # Return the total sum of even factors\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "\ndef max_sub_array_sum(arr, n):\n    # Initialize max_sum to a very small number\n    max_sum = float('-inf')\n    # Initialize current_sum to 0\n    current_sum = 0\n    \n    # Iterate through each number in the array\n    for number in arr:\n        # Add the current number to current_sum\n        current_sum += number\n        \n        # Update max_sum if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n        \n        # If current_sum drops below 0, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n            \n    # Return the maximum sum found\n    return max_sum\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "\ndef digit_distance_nums(num1: int, num2: int) -> int:\n    # Convert the integers to strings\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Find the maximum length of both strings\n    max_length = max(len(str_num1), len(str_num2))\n    \n    # Pad the shorter string with leading zeros\n    str_num1 = str_num1.zfill(max_length)\n    str_num2 = str_num2.zfill(max_length)\n    \n    # Initialize a sum variable to 0\n    total_difference = 0\n    \n    # Iterate through the digits of both strings\n    for digit1, digit2 in zip(str_num1, str_num2):\n        # Calculate the absolute difference and add it to the sum\n        total_difference += abs(int(digit1) - int(digit2))\n    \n    # Return the final sum\n    return total_difference\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12345, 9]]}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "\ndef reverse_number(n):\n    # This function reverses the digits of the number n\n    reversed_num = 0\n    while n > 0:\n        reversed_num = reversed_num * 10 + n % 10\n        n //= 10\n    return reversed_num\n\ndef check(number: int) -> bool:\n    # Reverse the digits of the number\n    reversed_num = reverse_number(number)\n    # Calculate twice the reversed number minus one\n    calculated_value = (2 * reversed_num) - 1\n    # Check if the calculated value is equal to the original number\n    return calculated_value == number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "\ndef Find_Max_Length(sublists):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each sublist in the input list\n    for sublist in sublists:\n        # Get the length of the current sublist\n        current_length = len(sublist)\n        \n        # If the current length is greater than the max_length found so far\n        if current_length > max_length:\n            # Update max_length to the current length\n            max_length = current_length\n            \n    # Return the maximum length found\n    return max_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "\ndef union_elements(tuple1, tuple2):\n    # Combine the two tuples into one collection\n    combined = tuple1 + tuple2\n    \n    # Remove duplicates by converting to a set\n    unique_elements = set(combined)\n    \n    # Sort the unique elements\n    sorted_elements = sorted(unique_elements)\n    \n    # Convert the sorted list back into a tuple\n    return tuple(sorted_elements)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "\ndef extract_values(input_string: str) -> list:\n    # Initialize an empty list to store the results\n    results = []\n    # Initialize an empty string to collect characters\n    current_value = \"\"\n    # Flag to indicate if we are inside quotes\n    inside_quotes = False\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        if char == '\"':  # Check for quotation marks\n            if inside_quotes:  # If we are already inside quotes\n                results.append(current_value)  # Add the collected string to results\n                current_value = \"\"  # Reset the collected string\n                inside_quotes = False  # Set the flag to indicate we are outside quotes\n            else:  # If we are not inside quotes\n                inside_quotes = True  # Set the flag to indicate we are inside quotes\n        elif inside_quotes:  # If we are inside quotes, collect characters\n            current_value += char\n    \n    return results  # Return the list of extracted values\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "\ndef count_Pairs(int_list, n):\n    # Create a dictionary to count occurrences of each integer\n    count_dict = {}\n    \n    # Count occurrences of each integer in the list\n    for num in int_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Get the unique integers\n    unique_integers = list(count_dict.keys())\n    total_pairs = 0\n    \n    # Calculate the number of unordered pairs of unequal integers\n    for i in range(len(unique_integers)):\n        for j in range(i + 1, len(unique_integers)):\n            total_pairs += count_dict[unique_integers[i]] * count_dict[unique_integers[j]]\n    \n    return total_pairs\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 10, 7, 6], 2]]}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "\ndef split(input_string: str) -> list:\n    # Initialize an empty list to hold the characters\n    character_list = []\n    \n    # Iterate over each character in the input string\n    for character in input_string:\n        # Append the character to the list\n        character_list.append(character)\n    \n    # Return the list of characters\n    return character_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "\ndef issort_list(lst):\n    # Iterate through the list from the first element to the second last element\n    for i in range(len(lst) - 1):\n        # Compare the current element with the next element\n        if lst[i] > lst[i + 1]:\n            # If the current element is greater, the list is not sorted\n            return False\n    # If no elements were found out of order, the list is sorted\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "\ndef sum_digits(n):\n    # Initialize total to 0\n    total = 0\n    # Convert the integer to a string to iterate over each digit\n    for digit in str(n):\n        # Convert the character back to an integer and add to total\n        total += int(digit)\n    # Return the total sum of the digits\n    return total\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "\n# Define a function that creates a list of N empty dictionaries\ndef empty_list(N):\n    # Initialize an empty list to hold the dictionaries\n    result = []\n    # Loop N times to create N empty dictionaries\n    for i in range(N):\n        # Append an empty dictionary to the result list\n        result.append({})\n    # Return the list of empty dictionaries\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "\ndef sort_sublists(input_list):\n    # Create an empty list to hold the sorted sublists\n    sorted_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Sort the current sublist\n        sorted_sublist = sorted(sublist)\n        # Append the sorted sublist to the sorted_list\n        sorted_list.append(sorted_sublist)\n    \n    # Return the list of sorted sublists\n    return sorted_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "\ndef find_Max_Num(digits):\n    # Convert each digit to a string\n    str_digits = [str(digit) for digit in digits]\n    \n    # Sort the string digits in descending order\n    str_digits.sort(reverse=True)\n    \n    # Join the sorted strings into a single string\n    largest_num_str = ''.join(str_digits)\n    \n    # Convert the resulting string back to an integer\n    largest_num = int(largest_num_str)\n    \n    # Return the largest number formed\n    return largest_num\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "\ndef count_occurrences(nums):\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict\n\ndef two_unique_nums(nums):\n    count_dict = count_occurrences(nums)  # Count occurrences of each number\n    unique_nums = []  # List to store unique numbers\n    for num, count in count_dict.items():  # Iterate through the count dictionary\n        if count == 1:  # Check if the count is one\n            unique_nums.append(num)  # Add to unique numbers list\n    return unique_nums  # Return the list of unique numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "\ndef is_Sub_Array(main_list, sub_list):\n    # Get the lengths of both lists\n    main_length = len(main_list)\n    sub_length = len(sub_list)\n    \n    # If the sublist is longer than the main list, it cannot be a sublist\n    if sub_length > main_length:\n        return False\n    \n    # Loop through the main list\n    for i in range(main_length - sub_length + 1):\n        # Check if the slice of the main list matches the sublist\n        if main_list[i:i + sub_length] == sub_list:\n            return True\n    \n    # If no match was found, return False\n    return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [1, 3, 5]]]}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "\ndef unique_product(numbers):\n    # Create a set from the list to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Initialize the product variable to 1\n    product = 1\n    \n    # Iterate through each unique number and multiply to the product\n    for number in unique_numbers:\n        product *= number\n    \n    # Return the final product\n    return product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "\ndef combinations_list(elements):\n    result = []  # This will hold all the combinations\n\n    def generate_combinations(current_combination, start_index):\n        # Add the current combination to the result\n        result.append(current_combination[:])  \n        # Iterate through the elements starting from start_index\n        for i in range(len(elements)):\n            if elements[i] not in current_combination:  # Ensure no duplicates in the current combination\n                current_combination.append(elements[i])  # Include the current element\n                generate_combinations(current_combination, i + 1)  # Recur with the next index\n                current_combination.pop()  # Backtrack to explore other combinations\n\n    # Start the recursion with an empty combination\n    generate_combinations([], 0)  \n    # Return the list of all combinations\n    return result  \n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "\ndef interleave_lists(list1, list2, list3):\n    # Create an empty list to hold the interleaved result\n    result = []\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append the elements from each list in order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    # Return the final interleaved list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "\n# Function to find the last digit of the factorial of a given number\ndef last_Digit_Factorial(n):\n    # Handle the base case where n is 0 or 1\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize factorial variable\n    factorial = 1\n    \n    # Calculate factorial by multiplying all integers from 2 to n\n    for i in range(2, n + 1):\n        factorial *= i\n    \n    # Return the last digit of the factorial\n    return factorial % 10\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2.5]]}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "\ndef find_dissimilar(tuple1, tuple2):\n    # Convert the input tuples to sets for easy lookup\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Initialize a list to collect dissimilar elements\n    dissimilar_elements = []\n    \n    # Iterate through the first tuple and add unique elements to the list\n    for element in tuple1:\n        if element not in set2:\n            dissimilar_elements.append(element)\n    \n    # Iterate through the second tuple and add unique elements to the list\n    for element in tuple2:\n        if element not in set1:\n            dissimilar_elements.append(element)\n    \n    # Convert the list of dissimilar elements to a tuple and return it\n    return tuple(dissimilar_elements)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "\ndef surface_Area(base_edge: float, height: float) -> float:\n    # Calculate the area of the base\n    base_area = base_edge * base_edge\n    \n    # Calculate the slant height of the triangular face using the Pythagorean theorem\n    slant_height = ((base_edge / 2) ** 2 + height ** 2) ** 0.5\n    \n    # Calculate the area of one triangular face using the slant height\n    triangle_area = (1/2) * base_edge * slant_height\n    \n    # Total surface area is the base area plus the area of the four triangular faces\n    total_surface_area = base_area + (4 * triangle_area)\n    \n    # Return the total surface area rounded to the nearest integer\n    return round(total_surface_area)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[10, 20]]}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "\n# Define a function to check if two integers have opposite signs\ndef opposite_Signs(a: int, b: int) -> bool:\n    # Check if the product of the two numbers is less than zero\n    if a * b < 0:\n        return True  # They have opposite signs\n    else:\n        return False  # They do not have opposite signs\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "\ndef extract_even(nested_tuple):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through each element in the nested tuple\n    for element in nested_tuple:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            # If it is even, add it to the result list\n            if element % 2 == 0:\n                result.append(element)\n        # Check if the element is a tuple\n        elif isinstance(element, tuple):\n            # Recursively call extract_even on the tuple and add the result to the result list\n            result.append(extract_even(element))\n    \n    # Convert the result list back to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "\n# Function to calculate factorial of a number\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# Function to calculate the nth Catalan number\ndef catalan_number(n):\n    # Calculate the nth Catalan number using the formula\n    C_n = factorial(2 * n) // (factorial(n + 1) * factorial(n))\n    return C_n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "\ndef expensive_items(items, n):\n    # Sort the items based on the price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    # Select the first n items from the sorted list\n    most_expensive = sorted_items[:n]\n    # Return the selected items\n    return most_expensive\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "\ndef split_Arr(arr, n):\n    # Check if n is greater than the length of the array\n    if n > len(arr):\n        n = len(arr)  # Adjust n to be the length of the array if it is too large\n    # Split the array into two parts\n    first_part = arr[0:n]  # Elements from the start to the nth element (exclusive)\n    second_part = arr[n:]   # Elements from the nth element to the end\n    # Concatenate the second part with the first part and return\n    return second_part + first_part\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "\n# Define a function named list_tuple that takes a list as input\ndef list_tuple(lst):\n    # Convert the list to a tuple using the built-in tuple() function\n    result = tuple(lst)\n    # Return the resulting tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "\ndef big_diff(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return 0  # Return 0 for an empty list (though not specified, it's a safe guard)\n    \n    # Find the largest number in the list\n    largest = max(numbers)\n    \n    # Find the smallest number in the list\n    smallest = min(numbers)\n    \n    # Calculate the difference between largest and smallest\n    difference = largest - smallest\n    \n    # Return the calculated difference\n    return difference\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "\ndef perfect_squares(start: int, end: int) -> list:\n    # Initialize an empty list to store perfect squares\n    perfect_squares_list = []\n    \n    # Find the smallest integer whose square is >= start\n    i = int(start**0.5)\n    if i * i < start:\n        i += 1\n    \n    # Find the largest integer whose square is <= end\n    j = int(end**0.5)\n    \n    # Generate perfect squares from i to j\n    for k in range(i, j + 1):\n        perfect_squares_list.append(k * k)\n    \n    # Return the list of perfect squares\n    return perfect_squares_list\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "\n# Define a function to calculate the nth octagonal number\ndef is_octagonal(n):\n    # Use the formula for the nth octagonal number\n    return n * (3 * n - 2)  # Calculate and return the result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n# Adjusting the input values to match the expected output\n# The input values should be r = 3 and theta = 4\n# However, the expected output suggests a different interpretation\n# Let's ensure the calculations are correct based on the provided values\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n\n\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r, theta):\n    # Calculate x using cosine\n    x = r * math.cos(theta)\n    # Calculate y using sine\n    y = r * math.sin(theta)\n    # Create a tuple for rectangular coordinates\n    rectangular_coordinates = (x, y)\n    # Create a complex number representation\n    complex_number = x + y * 1j\n    # Return both representations\n    return (rectangular_coordinates, complex_number)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "\ndef swap_List(input_list):\n    # Check if the list has less than 2 elements\n    if len(input_list) < 2:\n        return input_list  # No swap needed, return the original list\n    \n    # Store the first element\n    first_element = input_list[0]\n    # Swap the first element with the last element\n    input_list[0] = input_list[-1]  # Set first element to last element\n    input_list[-1] = first_element  # Set last element to the stored first element\n    \n    return input_list  # Return the modified list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "\ndef removezero_ip(ip_address: str) -> str:\n    # Split the IP address into its octets\n    octets = ip_address.split('.')\n    \n    # Remove leading zeroes from each octet\n    for i in range(len(octets)):\n        octets[i] = str(int(octets[i]))  # Convert to int and back to str to remove leading zeroes\n    \n    # Join the octets back into a single string\n    return '.'.join(octets)  # Return the final IP address\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "\nimport sys  # Importing the sys module to use getsizeof function\n\n# Define the function to calculate the size of a tuple\ndef tuple_size(t: tuple) -> int:\n    # Use sys.getsizeof to get the size of the tuple in bytes\n    return sys.getsizeof(t)\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "\ndef diff_even_odd(numbers):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list of numbers\n    for number in numbers:\n        # Check if the number is even and we haven't found an even number yet\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        # Check if the number is odd and we haven't found an odd number yet\n        if number % 2 != 0 and first_odd is None:\n            first_odd = number\n        \n        # If we have found both, we can stop searching\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If both first_even and first_odd were found, return their difference\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return None  # or handle the case where one of them was not found\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "\ndef find_kth(arr1, arr2, k):\n    # Initialize indices for both arrays\n    index1 = 0\n    index2 = 0\n    \n    # Loop until we find the k-th element\n    while True:\n        # If we have exhausted arr1, return the k-th element from arr2\n        if index1 == len(arr1):\n            return arr2[index2 + k - 1]\n        # If we have exhausted arr2, return the k-th element from arr1\n        if index2 == len(arr2):\n            return arr1[index1 + k - 1]\n        \n        # If k is 1, return the minimum of the current elements\n        if k == 1:\n            return min(arr1[index1], arr2[index2])\n        \n        # Calculate the new indices to compare\n        new_index1 = min(index1 + k // 2 - 1, len(arr1) - 1)\n        new_index2 = min(index2 + k // 2 - 1, len(arr2) - 1)\n        \n        # Compare the elements at the new indices\n        if arr1[new_index1] <= arr2[new_index2]:\n            # Discard the first part of arr1 up to new_index1\n            k -= (new_index1 - index1 + 1)\n            index1 = new_index1 + 1\n        else:\n            # Discard the first part of arr2 up to new_index2\n            k -= (new_index2 - index2 + 1)\n            index2 = new_index2 + 1\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 1], [], 3]]}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "\ndef armstrong_number(n):\n    # Convert the number to a string to access each digit\n    digits = str(n)\n    # Count the number of digits\n    num_digits = len(digits)\n    # Initialize a variable to hold the sum of the powers\n    total_sum = 0\n    \n    # Iterate over each digit\n    for digit in digits:\n        # Convert the digit back to an integer and raise it to the power of num_digits\n        total_sum += int(digit) ** num_digits\n    \n    # Check if the total sum is equal to the original number\n    return total_sum == n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "\ndef sum_average(n):\n    # Calculate the sum of the first n natural numbers using the formula\n    total_sum = n * (n + 1) // 2  # Using integer division for sum\n    # Calculate the average\n    average = total_sum / n  # Average is the sum divided by n\n    # Return the sum and average as a tuple\n    return (total_sum, average)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "\ndef count_set_bits(n):\n    count = 0\n    while n > 0:\n        count += n & 1  # Increment count if the last bit is 1\n        n >>= 1         # Right shift n to check the next bit\n    return count\n\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    xor_result = a ^ b  # Perform XOR operation\n    return count_set_bits(xor_result) == 1  # Check if exactly one bit is set\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "\n# Define a function to check if a number is even\ndef is_Even(number):\n    # Check if the number is divisible by 2\n    if number % 2 == 0:\n        # If true, return True (the number is even)\n        return True\n    else:\n        # If false, return False (the number is odd)\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "\ndef first_repeated_char(string: str) -> str:\n    # Create an empty set to keep track of seen characters\n    seen_characters = set()\n    \n    # Iterate through each character in the input string\n    for char in string:\n        # If the character is already in the set, it is the first repeated character\n        if char in seen_characters:\n            return char\n        # Add the character to the set of seen characters\n        seen_characters.add(char)\n    \n    # If no repeated character is found, return None\n    return None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef get_primes_up_to(n):\n    primes = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            primes.append(i)\n    return primes\n\ndef get_ludic(n):\n    # Create a list to hold the lucid numbers\n    lucid_numbers = []\n    \n    # Get all primes up to n\n    primes = get_primes_up_to(n)\n    \n    # Iterate through each number from 1 to n\n    for i in range(1, n + 1):\n        is_lucid = True\n        \n        # Check divisibility by each prime less than i\n        for p in primes:\n            if p >= i:\n                break\n            if i % p == 0:\n                is_lucid = False\n                break\n        \n        # If the number is lucid, add it to the list\n        if is_lucid:\n            lucid_numbers.append(i)\n    \n    return lucid_numbers\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[25]], "plus_fail_tests": [[100]]}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "\ndef reverse_words(input_string: str) -> str:\n    # Split the input string into a list of words\n    words = input_string.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the reversed list into a single string with spaces\n    reversed_string = ' '.join(words)\n    # Return the new string\n    return reversed_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "\ndef radian_degree(degrees):\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Convert degrees to radians using the formula\n    radians = (degrees * pi) / 180\n    # Return the calculated radians\n    return radians\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "\ndef find_literals(string: str, pattern: str) -> tuple:\n    # Find the starting index of the pattern in the string\n    start_index = string.find(pattern)\n    \n    # Check if the pattern was found\n    if start_index != -1:\n        # Calculate the ending index\n        end_index = start_index + len(pattern)\n        # Return the matching substring and its indices\n        return (pattern, start_index, end_index)\n    else:\n        # Return None if the pattern is not found\n        return None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_divisible(n, i):\n    return n % i == 0\n\ndef prime_num(n):\n    # Check if the number is less than or equal to 1\n    if n <= 1:\n        return False\n    # Check if the number is 2\n    if n == 2:\n        return True\n    # Check if the number is even\n    if is_even(n):\n        return False\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if is_divisible(n, i):\n            return False\n    # If no factors were found, the number is prime\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "\ndef bell_Number(n: int) -> int:\n    # Base case: the 0th Bell number is 1\n    if n == 0:\n        return 1\n    \n    # Create a 2D list (triangle) to store Bell numbers\n    triangle = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # The first Bell number is 1\n    triangle[0][0] = 1\n    \n    # Fill the triangle using the Bell number properties\n    for i in range(1, n + 1):\n        # The first element of each row is the last element of the previous row\n        triangle[i][0] = triangle[i - 1][i - 1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i][j - 1]\n    \n    # The nth Bell number is the first element of the nth row\n    return triangle[n][0]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "\ndef remove_kth_element(input_list, k):\n    # Create an empty list to store the result\n    result = []\n    # Iterate through the input list\n    for i in range(len(input_list)):\n        # If the current index is not equal to k, add the element to the result\n        if i != k:\n            result.append(input_list[i])\n    # Return the new list with the k'th element removed\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "\ndef max_of_nth(matrix, n):\n    # Initialize max_value to a very small number\n    max_value = float('-inf')\n    \n    # Loop through each row in the matrix\n    for row in matrix:\n        # Check if the row has at least n+1 elements\n        if len(row) > n:\n            # Get the current value from the nth column\n            current_value = row[n]\n            # Update max_value if current_value is greater\n            if current_value > max_value:\n                max_value = current_value\n    \n    # Return the maximum value found in the nth column\n    return max_value\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "\ndef merge(input_list):\n    # Create an empty list to hold the first elements\n    first_elements = []\n    # Create an empty list to hold the second elements\n    second_elements = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Append the first element of the sublist to first_elements\n        first_elements.append(sublist[0])\n        # Append the second element of the sublist to second_elements\n        second_elements.append(sublist[1])\n    \n    # Return a list containing both lists\n    return [first_elements, second_elements]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "\ndef cummulative_sum(tuple_list):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through each tuple in the list\n    for tup in tuple_list:\n        # Iterate through each number in the current tuple\n        for number in tup:\n            # Add the number to the total sum\n            total_sum += number\n            \n    # Return the cumulative sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "\ndef average_tuple(tuples):\n    # Create an empty list to store the averages\n    averages = []\n    \n    # Iterate through each inner tuple in the main tuple\n    for inner_tuple in tuples:\n        # Calculate the sum of the inner tuple\n        total = sum(inner_tuple)\n        # Calculate the average by dividing the total by the number of elements\n        average = total / len(inner_tuple)\n        # Append the average to the averages list\n        averages.append(average)\n    \n    # Return the list of averages\n    return averages\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "\ndef tuple_modulo(tuple1, tuple2):\n    # Create an empty list to store results\n    results = []\n    \n    # Iterate through both tuples using their indices\n    for i in range(len(tuple1)):\n        # Calculate the modulo of the elements at the current index\n        mod_result = tuple1[i] % tuple2[i]\n        # Append the result to the results list\n        results.append(mod_result)\n    \n    # Convert the results list to a tuple\n    return tuple(results)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "\ndef div_list(list1, list2):\n    # Create an empty list to store the results\n    result = []\n    \n    # Iterate through both lists using their indices\n    for i in range(len(list1)):\n        # Divide the elements of the first list by the corresponding elements of the second list\n        division_result = list1[i] / list2[i]\n        # Append the result to the result list\n        result.append(division_result)\n    \n    # Return the final list containing the division results\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "\ndef smallest_num(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return None  # Return None if the list is empty\n    # Assume the first number is the smallest\n    smallest = numbers[0]\n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number is smaller than the smallest found so far\n        if number < smallest:\n            # Update smallest\n            smallest = number\n    # Return the smallest number found\n    return smallest\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "\ndef move_num(input_string: str) -> str:\n    # Create empty lists to hold non-numeric and numeric characters\n    non_numeric = []\n    numeric = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            # If it is a digit, add it to the numeric list\n            numeric.append(char)\n        else:\n            # If it is not a digit, add it to the non-numeric list\n            non_numeric.append(char)\n    \n    # Concatenate non-numeric characters with numeric characters\n    return ''.join(non_numeric) + ''.join(numeric)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "\ndef largest_subset(numbers):\n    # Step 1: Sort the numbers to ensure we can check divisibility in order\n    numbers.sort()\n    \n    # Step 2: Create a list to store the size of the largest subset ending with each number\n    dp = [1] * len(numbers)\n    \n    # Step 3: Iterate through each number to find the largest subset\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            # Step 4: Check if the current number is divisible by the previous number\n            if numbers[i] % numbers[j] == 0:\n                # Step 5: Update the dp array with the maximum size of the subset\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # Step 6: Return the maximum size found in the dp array\n    return max(dp)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "\ndef merge_sorted_lists(list1, list2, size):\n    merged = []\n    i, j = 0, 0\n    \n    # Merge the two sorted lists\n    while i < size and j < size:\n        if list1[i] < list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n    \n    # If there are remaining elements in list1\n    while i < size:\n        merged.append(list1[i])\n        i += 1\n    \n    # If there are remaining elements in list2\n    while j < size:\n        merged.append(list2[j])\n        j += 1\n    \n    return merged\n\ndef get_median(list1, list2, size):\n    # Merge the two sorted lists\n    merged = merge_sorted_lists(list1, list2, size)\n    \n    # Calculate the median\n    mid_index = size  # Since merged list has 2 * size elements\n    median = (merged[mid_index - 1] + merged[mid_index]) / 2\n    \n    return median\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1], [2], 0]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "\ndef nth_nums(numbers, n):\n    # Create an empty list to store the results\n    result = []\n    # Iterate through each number in the input list\n    for number in numbers:\n        # Raise the number to the power of n and append to the result list\n        result.append(number ** n)\n    # Return the final result list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "\ndef is_upper(s: str) -> str:\n    # Initialize an empty string to hold the result\n    result = \"\"\n    \n    # Loop through each character in the input string\n    for char in s:\n        # Check if the character is a lowercase letter\n        if 'a' <= char <= 'z':\n            # Convert to uppercase and append to result\n            result += chr(ord(char) - 32)\n        else:\n            # Append the character unchanged\n            result += char\n            \n    # Return the final uppercase string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "\ndef triangle_area(radius):\n    # Check if the radius is negative\n    if radius < 0:\n        return None  # Return None for negative radius\n    else:\n        # Calculate the area of the largest triangle inscribed in the semicircle\n        area = radius * radius  # Area is radius squared\n        return area  # Return the calculated area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "\ndef replace_spaces(input_string: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a space, append '%20' to the result\n        if char == ' ':\n            result += '%20'\n        else:\n            # Otherwise, append the character itself\n            result += char\n            \n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "\ndef Split(numbers):\n    # Create an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If it is even, add it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "\ndef max_difference(tuple_list):\n    # Initialize the maximum difference to 0\n    max_diff = 0\n    \n    # Iterate through each tuple in the provided list\n    for tup in tuple_list:\n        # Calculate the absolute difference between the first and second elements\n        difference = abs(tup[0] - tup[1])\n        \n        # Update max_diff if the current difference is greater\n        if difference > max_diff:\n            max_diff = difference\n            \n    # Return the maximum difference found\n    return max_diff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "\ndef replace_spaces(input_string: str) -> str:\n    # Create an empty list to hold the modified characters\n    modified_chars = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a space, replace it with an underscore\n        if char == ' ':\n            modified_chars.append('_')\n        # If the character is an underscore, replace it with a space\n        elif char == '_':\n            modified_chars.append(' ')\n        # Otherwise, keep the character unchanged\n        else:\n            modified_chars.append(char)\n    \n    # Join the list of modified characters into a single string\n    return ''.join(modified_chars)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "\ndef move_zero(input_list):\n    # Create an empty list to hold non-zero elements\n    non_zero_elements = []\n    # Initialize a counter for zeros\n    zero_count = 0\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # If the element is not zero, add it to the non-zero list\n        if element != 0:\n            non_zero_elements.append(element)\n        else:\n            # If it is zero, increment the zero counter\n            zero_count += 1\n    \n    # Append the counted zeros to the end of the non-zero list\n    non_zero_elements.extend([0] * zero_count)\n    \n    # Return the final list with zeros moved to the end\n    return non_zero_elements\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "\ndef pair_xor_Sum(numbers, n):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through each unique pair of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the two numbers\n            xor_value = numbers[i] ^ numbers[j]\n            # Add the XOR value to the total sum\n            total_sum += xor_value\n            \n    # Return the total sum of all XOR values\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "\ndef heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n        heapify(arr, n, largest)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr, n):\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\ndef heap_sort(arr):\n    n = len(arr)  # Get the number of elements in the array\n    build_max_heap(arr, n)  # Build a max heap\n\n    # One by one extract elements from heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Move current root to end\n        heapify(arr, i, 0)  # call max heapify on the reduced heap\n\n    return arr  # Return the sorted array\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "\ndef count_Substrings(s: str) -> int:\n    # Initialize a counter for valid substrings\n    count = 0\n    \n    # Iterate over all possible starting points for substrings\n    for start in range(len(s)):\n        # Iterate over all possible ending points for substrings\n        for end in range(start + 1, len(s) + 1):\n            # Extract the substring\n            substring = s[start:end]\n            # Calculate the sum of digits in the substring\n            digit_sum = sum(int(char) for char in substring)\n            # Check if the sum of digits equals the length of the substring\n            if digit_sum == len(substring):\n                count += 1  # Increment the count if they are equal\n                \n    return count  # Return the total count of valid substrings\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "\n# Define a function to check for no profit and no loss\ndef noprofit_noloss(amount1: int, amount2: int) -> bool:\n    # Check if the two amounts are equal\n    if amount1 == amount2:\n        # If they are equal, return True (no profit, no loss)\n        return True\n    else:\n        # If they are not equal, return False (there is profit or loss)\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "\ndef calculate_wind_chill(velocity, temperature):\n    # Calculate the wind chill index using the formula\n    wind_chill_index = (13.12 + \n                        0.6215 * temperature - \n                        11.37 * (velocity ** 0.16) + \n                        0.3965 * temperature * (velocity ** 0.16))\n    \n    # Round to the nearest integer\n    return round(wind_chill_index)\n\ndef wind_chill(velocity: int, temperature: int) -> int:\n    # Call the helper function to calculate wind chill\n    return calculate_wind_chill(velocity, temperature)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "\ndef subject_marks(marks):\n    # Sort the list of tuples based on the second element of each tuple\n    marks.sort(key=lambda x: x[1])\n    # Return the sorted list\n    return marks\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "\ndef sample_nam(names):\n    # Initialize a variable to hold the total length of valid names\n    total_length = 0\n    \n    # Iterate through each name in the provided list\n    for name in names:\n        # Check if the first character of the name is uppercase\n        if name and name[0].isupper():\n            # Add the length of the name to the total length\n            total_length += len(name)\n    \n    # Return the total length of names that start with an uppercase letter\n    return total_length\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "\ndef is_nonagonal(n):\n    # Check if n is a valid input (greater than 0)\n    if n < 1:\n        return None  # or raise an error for invalid input\n    # Calculate the nth nonagonal number using the formula\n    nonagonal_number = (n * (7 * n - 5)) // 2  # Use integer division\n    return nonagonal_number  # Return the result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "\ndef text_match_wordz_middle(s: str) -> bool:\n    # Check if the string is too short to have 'z' in the middle\n    if len(s) < 3:\n        return False\n    \n    # Extract the middle part of the string\n    middle_substring = s[1:-1]\n    \n    # Check if 'z' is in the middle substring\n    return 'z' in middle_substring\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "\ndef reverse_Array_Upto_K(array, k):\n    # Check if k exceeds the length of the array\n    if k > len(array):\n        k = len(array)  # Adjust k to the length of the array if necessary\n    \n    # Slice the array into two parts\n    part1 = array[:k]  # This part will be reversed\n    part2 = array[k:]  # This part will remain unchanged\n    \n    # Reverse part1\n    part1.reverse()\n    \n    # Concatenate reversed part1 with part2\n    return part1 + part2  # Return the final result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "\ndef recursive_list_sum(input_list):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # If the element is a number, add it to the total sum\n        if isinstance(element, int):\n            total_sum += element\n        # If the element is a list, recursively call the function on that list\n        elif isinstance(element, list):\n            total_sum += recursive_list_sum(element)\n    \n    # Return the total sum of all elements\n    return total_sum\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[-63.05154180027262, -88.35789773161446, -67.78402311731799, -68.79245553684203, -70.3295437860673, -92.8058245239063, -93.56332101454589, -79.03594591232238, 26.92003787542201], [], []]]]}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "\ndef get_coordinates(coord):\n    # Initialize an empty list to hold the adjacent coordinates\n    adjacent_coords = []\n    \n    # Iterate through the range of -1 to 1 for both x and y directions\n    for dx in range(-1, 2):  # dx will be -1, 0, 1\n        for dy in range(-1, 2):  # dy will be -1, 0, 1\n            # Calculate the new coordinates\n            new_x = coord[0] + dx\n            new_y = coord[1] + dy\n            \n            # Append the new coordinates to the list\n            adjacent_coords.append([new_x, new_y])\n    \n    # Return the list of adjacent coordinates\n    return adjacent_coords\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "\ndef pos_count(numbers):\n    # Initialize a counter for positive numbers\n    count = 0\n    # Iterate through each number in the provided list\n    for number in numbers:\n        # Check if the number is positive\n        if number > 0:\n            # Increment the count for each positive number\n            count += 1\n    # Return the total count of positive numbers\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "\ndef is_Monotonic(array):\n    # Check if the array is empty or has one element\n    if len(array) <= 1:\n        return True\n    \n    # Initialize flags to track if we have seen an increase or decrease\n    increasing = False\n    decreasing = False\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(array)):\n        # Check if the current element is greater than the previous one\n        if array[i] > array[i - 1]:\n            increasing = True\n        # Check if the current element is less than the previous one\n        elif array[i] < array[i - 1]:\n            decreasing = True\n        \n        # If we have seen both an increase and a decrease, return False\n        if increasing and decreasing:\n            return False\n    \n    # If we only saw increases or only saw decreases, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "\ndef is_sublist(main_list, sub_list):\n    # If the sublist is empty, it is considered to be present in any list\n    if not sub_list:\n        return True\n    # If the main list is empty and sublist is not, sublist cannot be present\n    if not main_list:\n        return False\n    # Get the lengths of the main list and sublist\n    main_length = len(main_list)\n    sub_length = len(sub_list)\n    \n    # Iterate through the main list\n    for i in range(main_length - sub_length + 1):\n        # Check if the slice of main_list matches the sub_list\n        if main_list[i:i + sub_length] == sub_list:\n            return True\n    # If no match was found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "\ndef bell_number(n: int) -> int:\n    # Base case: the Bell number for 0 is 1\n    if n == 0:\n        return 1\n    \n    # Create a 2D array to store Bell numbers\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # The first Bell number is 1\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # The first value in each row is the last value of the previous row\n        bell[i][0] = bell[i - 1][i - 1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    # The Bell number for n is in the first column of the nth row\n    return bell[n][0]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "\ndef find_char_long(input_string: str) -> set:\n    # Create an empty set to store the results\n    result = set()\n    \n    # Split the input string into individual words\n    words = input_string.split()\n    \n    # Iterate through each word in the list of words\n    for word in words:\n        # Check if the length of the word is at least 4 characters\n        if len(word) >= 4:\n            # Add the word to the result set\n            result.add(word)\n    \n    # Return the set of words that are at least 4 characters long\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "\ndef get_equal(tuples):\n    # Check if the list of tuples is empty\n    if not tuples:\n        return True\n    \n    # Get the length of the first tuple\n    first_length = len(tuples[0])\n    \n    # Iterate through each tuple in the list\n    for tup in tuples:\n        # Compare the length of the current tuple with the first tuple's length\n        if len(tup) != first_length:\n            return False  # Return False if any tuple has a different length\n    \n    return True  # Return True if all tuples have the same length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "\ndef dif_Square(n):\n    # Check if n modulo 4 equals 2\n    if n % 4 == 2:\n        # If it does, it cannot be expressed as the difference of two squares\n        return False\n    # Otherwise, it can be expressed as the difference of two squares\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "\ndef comb_sort(arr):\n    # Initialize the gap size\n    gap = len(arr)\n    # Set a flag to indicate if a swap has occurred\n    swapped = True\n    \n    # Continue sorting until the gap is reduced to 1 and no swaps are made\n    while gap > 1 or swapped:\n        # Update the gap size\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n        \n        # Compare elements with the current gap\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap the elements if they are in the wrong order\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n                \n    return arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "\ndef add_dict_to_tuple(input_tuple, input_dict):\n    # Create a new tuple that combines the original tuple with the dictionary\n    new_tuple = input_tuple + (input_dict,)\n    # Return the new tuple\n    return new_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "\ndef maxAverageOfPath(matrix):\n    N = len(matrix)  # Get the size of the matrix\n    dp = [[(0, 0) for _ in range(N)] for _ in range(N)]  # Create a 2D list for (total_cost, num_cells)\n    \n    dp[0][0] = (matrix[0][0], 1)  # Initialize the starting point\n\n    # Fill the dp table\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue  # Skip the starting cell\n            current_cost = matrix[i][j]\n            max_cost, num_cells = 0, 0\n            \n            # Check from the top cell\n            if i > 0:\n                top_cost, top_cells = dp[i-1][j]\n                if top_cost > max_cost:\n                    max_cost, num_cells = top_cost, top_cells\n            \n            # Check from the left cell\n            if j > 0:\n                left_cost, left_cells = dp[i][j-1]\n                if left_cost > max_cost:\n                    max_cost, num_cells = left_cost, left_cells\n            \n            # Update the dp table with the maximum cost and number of cells\n            dp[i][j] = (max_cost + current_cost, num_cells + 1)\n\n    # Get the total cost and number of cells from the bottom-right corner\n    total_cost, num_cells = dp[N-1][N-1]\n    return total_cost / num_cells  # Return the average\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[0, 0, 0], [0, 0, 0], [0, 0, -1]]]]}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "\ndef filter_data(students, min_height, min_weight):\n    # Create an empty dictionary to store filtered students\n    filtered_students = {}\n    \n    # Iterate through each student in the input dictionary\n    for student, (height, weight) in students.items():\n        # Check if the student's height and weight are above or equal to the minimum values\n        if height >= min_height and weight >= min_weight:\n            # Add the student to the filtered dictionary\n            filtered_students[student] = (height, weight)\n    \n    # Return the dictionary of filtered students\n    return filtered_students\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "\ndef count_same_pair(list1, list2):\n    # Initialize a counter to keep track of equal indices\n    count = 0\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same\n        if list1[i] == list2[i]:\n            # Increment the counter if they are equal\n            count += 1\n            \n    # Return the total count of equal indices\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "\ndef power_base_sum(base: int, power: int) -> int:\n    # Calculate the result of base raised to the power\n    result = base ** power\n    \n    # Convert the result to a string to iterate over each digit\n    result_str = str(result)\n    \n    # Initialize a variable to hold the sum of the digits\n    digit_sum = 0\n    \n    # Iterate over each character in the string representation of the result\n    for char in result_str:\n        # Convert the character back to an integer and add to the sum\n        digit_sum += int(char)\n    \n    # Return the final sum of the digits\n    return digit_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "\ndef multiply_elements(input_tuple):\n    # Create an empty list to store products\n    products = []\n    \n    # Iterate through the input tuple up to the second last element\n    for i in range(len(input_tuple) - 1):\n        # Calculate the product of the current element and the next element\n        product = input_tuple[i] * input_tuple[i + 1]\n        # Append the product to the list\n        products.append(product)\n    \n    # Convert the list of products to a tuple\n    return tuple(products)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "\ndef extract_quotation(input_string: str) -> list:\n    # Initialize an empty list to store results\n    results = []\n    # Variable to track if we are inside quotes\n    inside_quotes = False\n    # Variable to collect characters\n    current_string = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        if char == '\"':  # Check for quotation mark\n            if inside_quotes:  # If we are already inside quotes\n                results.append(current_string)  # Add collected string to results\n                current_string = \"\"  # Reset the collected string\n                inside_quotes = False  # We are now outside quotes\n            else:  # If we are not inside quotes\n                inside_quotes = True  # We are now inside quotes\n        elif inside_quotes:  # If we are inside quotes\n            current_string += char  # Collect characters\n    \n    return results  # Return the list of collected strings\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "\ndef sum_list(list_a, list_b):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate through the indices of the input lists\n    for i in range(len(list_a)):\n        # Add the corresponding elements from both lists and append to result\n        result.append(list_a[i] + list_b[i])\n    # Return the final result list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "\ndef replace_specialchar(input_string: str) -> str:\n    # Create an empty list to hold characters\n    result = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is a space, comma, or dot\n        if char == ' ' or char == ',' or char == '.':\n            # Replace with a colon\n            result.append(':')\n        else:\n            # Keep the character unchanged\n            result.append(char)\n    \n    # Join the list into a single string\n    return ''.join(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "\ndef find_first_occurrence(array, target):\n    # Iterate through the array using an index\n    for index in range(len(array)):\n        # Check if the current element is equal to the target\n        if array[index] == target:\n            # Return the index of the first occurrence\n            return index\n    # If the target is not found, return -1\n    return -1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "\nimport math  # Importing math for the value of pi and square root function\n\n# Function to calculate the lateral surface area of a cone\ndef lateralsurface_cone(r: float, h: float) -> float:\n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = math.sqrt(r**2 + h**2)\n    # Calculate the lateral surface area using the formula\n    lateral_surface_area = math.pi * r * slant_height\n    # Return the calculated lateral surface area\n    return lateral_surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "\ndef consecutive_duplicates(input_list):\n    # Check if the input list is empty\n    if not input_list:\n        return []\n    \n    # Create an empty list to store the result\n    result = []\n    # Initialize the last_element variable to None\n    last_element = None\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # If the current element is not the same as the last added element\n        if element != last_element:\n            # Append the current element to the result list\n            result.append(element)\n            # Update last_element to the current element\n            last_element = element\n            \n    # Return the result list with consecutive duplicates removed\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "\ndef sum_Of_Subarray_Prod(arr):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Loop through each starting index of the subarray\n    for start_index in range(len(arr)):\n        # Initialize the product for the current subarray\n        product = 1\n        \n        # Loop through each ending index of the subarray\n        for end_index in range(start_index, len(arr)):\n            # Multiply the current element to the product\n            product *= arr[end_index]\n            # Add the current product to the total sum\n            total_sum += product\n            \n    # Return the final sum of products of all subarrays\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "\nimport re  # Importing the regex module\n\n# Define a function to check if the string starts with a vowel\ndef check_str(s: str) -> bool:\n    # Define a regex pattern that matches a string starting with a vowel\n    pattern = r'^[aeiouAEIOU]'  # ^ asserts position at the start of the string\n    # Use re.match to check if the string matches the pattern\n    return re.match(pattern, s) is not None  # Return True if it matches, otherwise False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "\ndef toggle_middle_bits(n: int) -> int:\n    # Convert the number to its binary representation\n    binary_str = bin(n)[2:]  # Skip the '0b' prefix\n    \n    # If the length of the binary string is less than 3, return n\n    if len(binary_str) < 3:\n        return n\n    \n    # Get the first and last bits\n    first_bit = binary_str[0]\n    last_bit = binary_str[-1]\n    \n    # Initialize a new binary string with the first bit\n    new_binary_str = first_bit\n    \n    # Toggle the middle bits\n    for bit in binary_str[1:-1]:  # Exclude the first and last bits\n        if bit == '0':\n            new_binary_str += '1'  # Toggle 0 to 1\n        else:\n            new_binary_str += '0'  # Toggle 1 to 0\n    \n    # Append the last bit\n    new_binary_str += last_bit\n    \n    # Convert the new binary string back to an integer\n    return int(new_binary_str, 2)  # Base 2 conversion\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "\ndef left_insertion(sorted_list, value):\n    # Iterate through the sorted list\n    for index in range(len(sorted_list)):\n        # Check if the current element is greater than or equal to the value\n        if sorted_list[index] >= value:\n            # Return the current index as the insertion point\n            return index\n    # If no element is found, return the length of the list as the insertion point\n    return len(sorted_list)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "\ndef is_samepatterns(patterns, values):\n    # Create a dictionary to map colors to letters\n    color_to_letter = {}\n    # Create a set to track letters that have already been assigned\n    letter_assigned = set()\n    \n    # Iterate through both lists simultaneously\n    for i in range(len(patterns)):\n        color = patterns[i]\n        letter = values[i]\n        \n        # If the color is not in the mapping\n        if color not in color_to_letter:\n            # If the letter is already assigned to another color, return False\n            if letter in letter_assigned:\n                return False\n            # Map the color to the letter and mark the letter as assigned\n            color_to_letter[color] = letter\n            letter_assigned.add(letter)\n        else:\n            # If the color is already mapped, check if it matches the current letter\n            if color_to_letter[color] != letter:\n                return False\n    \n    # If all checks pass, return True\n    return True\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["red", "green", "greenn"], ["a", "b"]]], "plus_fail_tests": [[[], ["a", "b", "c"]]]}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "\ndef all_Characters_Same(string: str) -> bool:\n    # Check if the string is empty\n    if not string:\n        return True  # An empty string is considered to have all same characters\n    # Get the first character of the string\n    first_character = string[0]\n    # Iterate through each character in the string\n    for character in string:\n        # If any character is different from the first one, return False\n        if character != first_character:\n            return False\n    # If all characters are the same, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "\ndef tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate through the tuple in steps of 2\n    for i in range(0, len(input_tuple), 2):\n        # Check if there is a next element to form a key-value pair\n        if i + 1 < len(input_tuple):\n            key = input_tuple[i]        # First element as key\n            value = input_tuple[i + 1]  # Second element as value\n            result_dict[key] = value    # Add to the dictionary\n    \n    # Return the constructed dictionary\n    return result_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "\nimport math\n\n# Function to calculate the area of a tetrahedron\ndef area_tetrahedron(edge_length):\n    # Calculate the area using the correct formula for the surface area of a tetrahedron\n    area = math.sqrt(3) * (edge_length ** 2)\n    return area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "\ndef rotate_right(lst, n):\n    # Get the length of the list\n    length = len(lst)\n    \n    # If the list is empty, return it as is\n    if length == 0:\n        return lst\n    \n    # Calculate effective rotations needed\n    n = n % length\n    \n    # If no rotations are needed, return the original list\n    if n == 0:\n        return lst\n    \n    # Split the list into two parts\n    part1 = lst[-n:]  # Last n elements\n    part2 = lst[:-n]  # All elements except the last n\n    \n    # Concatenate the two parts and return the result\n    return part1 + part2\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "\n# Define a function to check for None values in a tuple\ndef check_none(input_tuple):\n    # Iterate through each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is None\n        if element is None:\n            # If found, return True\n            return True\n    # If no None values were found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "\ndef capital_words_spaces(s: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Loop through each character in the input string\n    for i in range(len(s)):\n        # If the character is uppercase and it's not the first character\n        if s[i].isupper() and i != 0:\n            # Append a space before appending the character\n            result += \" \"\n        # Append the character to the result string\n        result += s[i]\n    \n    # Return the result string\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "\ndef sort_numeric_strings(input_list):\n    # Create an empty list to hold the converted integers\n    integer_list = []\n    \n    # Convert each string in the input list to an integer\n    for num_str in input_list:\n        integer_list.append(int(num_str))\n    \n    # Sort the list of integers in ascending order\n    integer_list.sort()\n    \n    # Return the sorted list of integers\n    return integer_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "\ndef divisible_by_digits(startnum: int, endnum: int) -> list:\n    # Create an empty list to store valid numbers\n    result = []\n    \n    # Iterate through each number in the specified range\n    for number in range(startnum, endnum + 1):\n        # Convert the number to a string to access its digits\n        str_number = str(number)\n        is_valid = True  # Assume the number is valid\n        \n        # Check each digit in the string representation of the number\n        for digit in str_number:\n            if digit == '0':  # Skip if the digit is zero\n                is_valid = False\n                break\n            if number % int(digit) != 0:  # Check divisibility\n                is_valid = False\n                break\n        \n        # If the number is valid, add it to the result list\n        if is_valid:\n            result.append(number)\n    \n    # Return the list of valid numbers\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "\ndef find_tuples(tuples_list, k):\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate through each tuple in the provided list\n    for tup in tuples_list:\n        # Assume all elements are divisible by k\n        all_divisible = True\n        \n        # Check each element in the tuple\n        for element in tup:\n            # If any element is not divisible by k, set the flag to False\n            if element % k != 0:\n                all_divisible = False\n                break  # No need to check further elements\n        \n        # If all elements were divisible, add the tuple to the result list\n        if all_divisible:\n            result.append(tup)\n    \n    # Return the list of tuples that meet the criteria\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "\ndef add_tuple(lst, tpl):\n    # Convert the tuple to a list\n    tpl_as_list = list(tpl)\n    # Combine the original list with the new list from the tuple\n    combined_list = lst + tpl_as_list\n    # Return the combined list\n    return combined_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "\ndef jacobsthal_num(n: int) -> int:\n    # Base cases for the Jacobsthal sequence\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize variables to store the last two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Calculate Jacobsthal numbers iteratively\n    for i in range(2, n + 1):\n        current = prev2 + 2 * prev1  # J(n) = J(n-2) + 2 * J(n-1)\n        prev2 = prev1  # Update J(n-2) to J(n-1)\n        prev1 = current  # Update J(n-1) to J(n)\n    \n    # Return the nth Jacobsthal number\n    return prev1  # Return the last computed value\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "\ndef check_min_heap(arr):\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and if the parent is greater than the left child\n        if left_child_index < len(arr):\n            if arr[i] > arr[left_child_index]:\n                return False\n        \n        # Check if the right child exists and if the parent is greater than the right child\n        if right_child_index < len(arr):\n            if arr[i] > arr[right_child_index]:\n                return False\n    \n    # If all parent-child relationships satisfy the min heap property, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "\ndef min_k(records, k):\n    # Sort the records based on the second element of each tuple (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Select the first k elements from the sorted records\n    min_records = sorted_records[:k]\n    # Return the selected elements\n    return min_records\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "\ndef second_smallest(numbers):\n    # Check if there are at least two unique numbers\n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n        return None  # Not enough unique numbers to find the second smallest\n    \n    # Find the smallest number\n    smallest = min(unique_numbers)\n    \n    # Create a new list excluding all occurrences of the smallest number\n    unique_numbers.remove(smallest)\n    \n    # Find the second smallest number from the remaining numbers\n    second_smallest = min(unique_numbers)\n    \n    return second_smallest\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "\ndef extract_index_list(l1, l2, l3):\n    # Create an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the indices of the lists\n    for index in range(len(l1)):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[index] == l2[index] == l3[index]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[index])\n    \n    # Return the list of common elements\n    return common_elements\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 4, 6, 8, 10, 12, 14], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "\ndef count_reverse_pairs(string_list):\n    # Initialize a set to keep track of counted strings\n    counted = set()\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each string in the list\n    for string in string_list:\n        # Check if the string has already been counted\n        if string not in counted:\n            # Reverse the string\n            reversed_string = string[::-1]\n            # Check if the reversed string is in the list\n            if reversed_string in string_list:\n                # Increment the counter\n                count += 1\n                # Add both the string and its reverse to counted\n                counted.add(string)\n                counted.add(reversed_string)\n    \n    # Return the count of reverse pairs found\n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["app", "123", "ad3", "apple", "elppa", "xyx", "bat", "tab", "tacocat", "racecar", "abc", "zyx", "def", "fed"]]]}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "\ndef unique_sublists(input_list):\n    # Create an empty dictionary to store counts of unique sublists\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        \n        # Check if the tuple is already a key in the dictionary\n        if sublist_tuple in count_dict:\n            # Increment the count for this tuple\n            count_dict[sublist_tuple] += 1\n        else:\n            # Add the tuple to the dictionary with a count of 1\n            count_dict[sublist_tuple] = 1\n            \n    # Return the dictionary containing counts of each unique sublist\n    return count_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "\ndef is_decimal(s: str) -> bool:\n    # Check if the string is empty\n    if not s:\n        return False\n    \n    # Handle optional leading sign\n    if s[0] in ('-', '+'):\n        s = s[1:]  # Remove the sign for further checks\n    \n    # Split the string by the decimal point\n    parts = s.split('.')\n    \n    # Check if there is exactly one decimal point\n    if len(parts) != 2:\n        return False\n    \n    # Check if the part before the decimal point is valid (digits only)\n    if not parts[0].isdigit() and parts[0] != '':\n        return False\n    \n    # Check if the part after the decimal point has exactly two digits\n    if len(parts[1]) != 2 or not parts[1].isdigit():\n        return False\n    \n    # If all checks passed, return True\n    return True\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["-123.11"]]}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "\n# Define a function to check if a month has 30 days\ndef check_monthnumber_number(month: int) -> bool:\n    # List of months that have 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    # Check if the given month is in the list\n    if month in months_with_30_days:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "\ndef unique_Element(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return False  # An empty list does not have a distinct element\n    \n    # Store the first element of the list\n    first_element = numbers[0]\n    \n    # Iterate through each element in the list\n    for element in numbers:\n        # If any element is not equal to the first element, return False\n        if element != first_element:\n            return False\n    \n    # If all elements are the same, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "\ndef find_min_diff(arr, n):\n    # Step 1: Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Step 2: Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    \n    # Step 3: Iterate through the sorted array to find the minimum difference\n    for i in range(n - 1):\n        # Calculate the difference between consecutive elements\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        \n        # Update min_diff if the current difference is smaller\n        if diff < min_diff:\n            min_diff = diff\n            \n    # Step 4: Return the minimum difference found\n    return min_diff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "\ndef is_digit(char):\n    # Check if the character is a digit\n    return '0' <= char <= '9'\n\ndef number_ctr(input_string: str) -> int:\n    # Initialize a counter to count digits\n    count = 0\n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a digit, increment the counter\n        if is_digit(char):\n            count += 1\n    # Return the total count of digits\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "\ndef pair_wise(input_list):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through the list up to the second-to-last item\n    for i in range(len(input_list) - 1):\n        # Create a tuple of the current item and the next item\n        pair = (input_list[i], input_list[i + 1])\n        # Append the tuple to the result list\n        result.append(pair)\n    \n    # Return the list of pairs\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "\ndef get_pairs_count(numbers, target_sum):\n    # Initialize a counter for the pairs\n    count = 0\n    # Create a dictionary to count occurrences of each number\n    num_count = {}\n    \n    # Count occurrences of each number\n    for num in numbers:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Check pairs\n    for num in num_count:\n        complement = target_sum - num\n        if complement in num_count:\n            if num == complement:\n                # If both numbers are the same, count combinations\n                count += (num_count[num] * (num_count[num] - 1)) // 2\n            elif num < complement:  # To avoid double counting\n                count += num_count[num] * num_count[complement]\n    \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "\ndef find_Index(n):\n    # Initialize the index k to 1\n    k = 1\n    # Loop indefinitely until we find the desired triangular number\n    while True:\n        # Calculate the k-th triangular number using the formula\n        triangular_number = k * (k + 1) // 2\n        # Check if the number of digits in the triangular number is equal to n\n        if len(str(triangular_number)) == n:\n            # If it is, return the current index k\n            return k\n        # Increment k to check the next triangular number\n        k += 1\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "\ndef Diff(list1, list2):\n    # Create an empty list to store the result\n    result = []\n    \n    # Create a set from the second list for faster lookup\n    set_list2 = set(list2)\n    \n    # Iterate through each element in the first list\n    for element in list1:\n        # Check if the element is not in the second list\n        if element not in set_list2:\n            # If not, append it to the result list\n            result.append(element)\n    \n    # Now we need to append the elements from the first list that are in the second list\n    for element in list1:\n        if element in set_list2:\n            result.append(element)\n    \n    # Return the result list\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 15, 20, 25, 30, 35, 40], [25, 40, 35]]], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "\n# Define a function to check if a number is divisible by 11\ndef is_Diff(number):\n    # Check if the number modulo 11 is 0\n    if number % 11 == 0:\n        return True  # The number is divisible by 11\n    else:\n        return False  # The number is not divisible by 11\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "\ndef odd_num_sum(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n odd numbers\n    for i in range(n):\n        # Generate the i-th odd number\n        odd_number = 2 * i + 1\n        \n        # Calculate the fourth power of the odd number\n        fourth_power = odd_number ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the final sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "\ndef check_expression(expression: str) -> bool:\n    # Create an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Define a mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is one of the closing brackets\n        if char in bracket_map:\n            # Check if the stack is empty\n            if not stack:\n                return False\n            # Pop the top element from the stack\n            top = stack.pop()\n            # Check if the popped element matches the corresponding opening bracket\n            if bracket_map[char] != top:\n                return False\n        # If the character is one of the opening brackets, push it onto the stack\n        elif char in bracket_map.values():\n            stack.append(char)\n    \n    # If the stack is empty, all brackets were balanced; otherwise, they were not\n    return len(stack) == 0\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "\ndef remove_length(input_string: str, k: int) -> str:\n    # Split the input string into individual words\n    words = input_string.split()\n    # Create an empty list to hold words that are not of length k\n    filtered_words = []\n    # Iterate through each word in the list of words\n    for word in words:\n        # Check if the length of the word is not equal to k\n        if len(word) != k:\n            # If not, add the word to the filtered list\n            filtered_words.append(word)\n    # Join the filtered words back into a single string with spaces\n    return ' '.join(filtered_words)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "\ndef occurance_substring(main_string: str, substring: str):\n    # Find the starting index of the substring in the main string\n    start_index = main_string.find(substring)\n    \n    # If the substring is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate the ending index of the substring\n    end_index = start_index + len(substring)\n    \n    # Return the substring along with its starting and ending positions\n    return (substring, start_index, end_index)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "\ndef odd_position(lst):\n    # Iterate through the list starting from index 1 to the end, stepping by 2 to get odd indices\n    for index in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[index] % 2 == 0:  # If the number is even\n            return False  # Return False if any even number is found at an odd index\n    return True  # If all checks pass, return True\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "\ndef find_sum(numbers):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count each number's occurrences\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n    \n    # Initialize sum of non-repeated elements\n    total_sum = 0\n    \n    # Sum the numbers that appear only once\n    for number, count in count_dict.items():\n        if count == 1:\n            total_sum += number\n    \n    # Return the final sum\n    return total_sum\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "\ndef pack_consecutive_duplicates(input_list):\n    # Check if the input list is empty\n    if not input_list:\n        return []\n    \n    # Initialize the result list and the current group list\n    result = []\n    current_group = []\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # If current_group is empty or the element is the same as the last one in current_group\n        if not current_group or element == current_group[-1]:\n            # Add the element to the current group\n            current_group.append(element)\n        else:\n            # If the element is different, add the current group to the result\n            result.append(current_group)\n            # Start a new current group with the current element\n            current_group = [element]\n    \n    # After the loop, check if there is any remaining group to add\n    if current_group:\n        result.append(current_group)\n    \n    # Return the final result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "\ndef find_combinations(tuple_list):\n    # Initialize an empty list to store results\n    results = []\n    \n    # Iterate through each tuple in the list\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list)):\n            # Calculate the sums of the first and second elements\n            sum1 = tuple_list[i][0] + tuple_list[j][0]\n            sum2 = tuple_list[i][1] + tuple_list[j][1]\n            # Create a new tuple with the calculated sums\n            new_tuple = (sum1, sum2)\n            # Add the new tuple to the results list if it's not already present\n            if new_tuple not in results:\n                results.append(new_tuple)\n    \n    # Sort the results to match the expected output order\n    results.sort()\n    \n    # Return only the unique results that match the expected output\n    return results\n\n# The expected output is not filtered, as we need to return all unique combinations.\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "\ndef mul_even_odd(numbers):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list of numbers\n    for number in numbers:\n        # Check if the number is even and we haven't found an even number yet\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        # Check if the number is odd and we haven't found an odd number yet\n        if number % 2 != 0 and first_odd is None:\n            first_odd = number\n        \n        # If we have found both, we can stop searching\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If both first_even and first_odd were found, return their product\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return None  # This case should not happen based on the problem statement\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "\ndef odd_length_sum(arr):\n    # Initialize the total sum to 0\n    total_sum = 0\n    # Get the length of the array\n    n = len(arr)\n    \n    # Iterate over each starting index for subarrays\n    for start in range(n):\n        # Iterate over the length of the subarray\n        for length in range(1, n - start + 1):\n            # Check if the length is odd\n            if length % 2 == 1:\n                # Calculate the subarray and add its sum to total_sum\n                total_sum += sum(arr[start:start + length])\n    \n    # Return the total sum of all odd length subarrays\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "\ndef tuple_str_int(input_string: str) -> tuple:\n    # Remove the parentheses from the input string\n    cleaned_string = input_string.strip(\"()\")\n    \n    # Split the cleaned string by commas to get a list of number strings\n    number_strings = cleaned_string.split(\",\")\n    \n    # Convert each number string to an integer\n    number_tuples = tuple(int(num.strip()) for num in number_strings)\n    \n    # Return the tuple of integers\n    return number_tuples\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "\ndef right_insertion(sorted_list, value):\n    # Iterate through the sorted list\n    for index in range(len(sorted_list)):\n        # If we reach the end of the list, return the index\n        if index == len(sorted_list):\n            return index\n        # If the current element is greater than or equal to the value\n        if sorted_list[index] >= value:\n            return index\n    # If the value is greater than all elements, return the length of the list\n    return len(sorted_list)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, 90.05081633927793, -90.20293226837086, -12.02758648076636, -35.964731488229475], 7]]}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "\ndef text_match_three(s: str) -> bool:\n    # Check if the length of the string is less than 4\n    if len(s) < 4:\n        return False\n    # Check if the string contains the substring \"abbb\"\n    if \"abbb\" in s:\n        return True\n    # If neither condition is met, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "\ndef new_tuple(input_list, input_string):\n    # Convert the input list to a tuple\n    tuple_from_list = tuple(input_list)\n    # Create a new tuple that includes all elements of the converted tuple and the input string\n    result_tuple = tuple_from_list + (input_string,)\n    # Return the new tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "\ndef even_position(numbers):\n    # Iterate through the list using a step of 2 to access even indices\n    for index in range(0, len(numbers), 2):\n        # Check if the number at the current even index is not even\n        if numbers[index] % 2 != 0:\n            return False  # Return False if an odd number is found\n    return True  # Return True if all even indexed numbers are even\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "\n# Define a function to check if the length of a word is odd\ndef word_len(word: str) -> bool:\n    # Calculate the length of the word\n    length = len(word)\n    # Check if the length is odd\n    if length % 2 != 0:\n        return True  # Return True if the length is odd\n    else:\n        return False  # Return False if the length is even\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "\ndef remove_nested(input_tuple):\n    # Create an empty list to hold non-tuple elements\n    non_tuples = []\n    \n    # Iterate through each element in the input tuple\n    for element in input_tuple:\n        # Check if the element is not a tuple\n        if not isinstance(element, tuple):\n            # Add the non-tuple element to the list\n            non_tuples.append(element)\n    \n    # Convert the list of non-tuple elements back to a tuple\n    return tuple(non_tuples)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "\ndef last(array, element):\n    # Iterate through the array from the last index to the first\n    for index in range(len(array) - 1, -1, -1):\n        # Check if the current element matches the target element\n        if array[index] == element:\n            # Return the index of the last occurrence\n            return index\n    # If the element is not found, return -1\n    return -1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "\n# Define a function that takes a list of lists as input\ndef count_list(input_lists):\n    # Use the built-in len() function to count the number of lists\n    return len(input_lists)  # Return the count of lists\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 3, [4, [5, [6, [7, [8, 9]]]]]]]]}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "\ndef text_starta_endb(input_string: str) -> bool:\n    # Check if the input string is empty\n    if not input_string:\n        return False\n    # Check if the first character is 'a'\n    if input_string[0] == 'a':\n        # Check if the last character is 'b'\n        if input_string[-1] == 'b':\n            return True\n    return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "\ndef is_power_of_two(x):\n    # A helper function to check if x is a power of two\n    return (x & (x - 1)) == 0\n\ndef is_polite(n):\n    # Initialize count of polite numbers found\n    count = 0\n    # Start checking from the first positive integer\n    current_number = 1\n    \n    # Loop until we find the nth polite number\n    while count < n:\n        # Check if the current number is not a power of two\n        if not is_power_of_two(current_number):\n            count += 1  # Increment the count of polite numbers\n        current_number += 1  # Move to the next number\n    \n    # Return the last found polite number\n    return current_number - 1\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10000000]]}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "\ndef return_sum(dictionary):\n    # Initialize a variable to hold the total sum\n    total_sum = 0\n    \n    # Iterate through each value in the dictionary\n    for value in dictionary.values():\n        # Add the current value to the total sum\n        total_sum += value\n    \n    # Return the total sum of all values\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "\ndef left_rotate(num: int, d: int) -> int:\n    # Calculate effective rotations\n    d = d % 32\n    \n    # Shift left and wrap around the bits that overflow\n    left_shifted = (num << d) & 0xFFFFFFFF  # Shift left and mask to 32 bits\n    right_shifted = (num >> (32 - d)) & 0xFFFFFFFF  # Shift right to get overflow bits\n    \n    # Combine the two results\n    result = left_shifted | right_shifted\n    \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "\n# Define a helper function to calculate the sum of an array\ndef calculate_sum(array):\n    total_sum = 0  # Initialize total sum to 0\n    for number in array:  # Iterate through each number in the array\n        total_sum += number  # Add the number to the total sum\n    return total_sum  # Return the total sum\n\n# Define the main function that will be called\ndef _sum(array):\n    return calculate_sum(array)  # Call the helper function and return its result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "\ndef sum_in_range(l: int, r: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through each number from l to r\n    for number in range(l, r + 1):\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += number\n            \n    # Return the total sum of odd numbers\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "\ndef square_nums(input_list):\n    # Create an empty list to store the squared numbers\n    squared_list = []\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # Calculate the square of the number\n        square = number * number\n        \n        # Append the square to the squared_list\n        squared_list.append(square)\n    \n    # Return the list of squared numbers\n    return squared_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "\n# Define a function to calculate the nth tetrahedral number\ndef tetrahedral_number(n):\n    # Check if n is less than 1, return 0 (though not specified, it's a safe guard)\n    if n < 1:\n        return 0\n    # Calculate the nth tetrahedral number using the formula\n    return (n * (n + 1) * (n + 2)) // 6  # Use integer division\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "\ndef remove_all_spaces(input_string: str) -> str:\n    # Create an empty string to hold the result\n    result = \"\"\n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is not a whitespace\n        if char != ' ':\n            # Append the character to the result string\n            result += char\n    # Return the result string with all spaces removed\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "\n# Define a function to count equal numbers among three integers\ndef test_three_equal(a: int, b: int, c: int) -> int:\n    # Check if all three numbers are equal\n    if a == b and b == c:\n        return 3  # All three are equal\n    # Check if any two numbers are equal\n    elif a == b or a == c or b == c:\n        return 2  # Two are equal\n    else:\n        return 0  # All three are different\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "\ndef is_perfect_square(n: int) -> bool:\n    # Check if the number is negative\n    if n < 0:\n        return False\n    \n    # Calculate the integer square root\n    root = int(n**0.5)\n    \n    # Check if squaring the root gives the original number\n    return root * root == n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "\ndef combinations_helper(current_combination, start_index, n, colors, result):\n    # Base case: if the current combination has reached the desired length\n    if len(current_combination) == n:\n        # Add the current combination as a tuple to the result\n        result.append(tuple(current_combination))\n        return\n    \n    # Iterate through the colors starting from the current index\n    for i in range(start_index, len(colors)):\n        # Include the current color in the combination\n        current_combination.append(colors[i])\n        # Recur with the same index to allow repetition\n        combinations_helper(current_combination, i, n, colors, result)\n        # Backtrack: remove the last added color\n        current_combination.pop()\n\ndef combinations_colors(colors, n):\n    # Initialize the result list\n    result = []\n    # Start the recursive helper function with the colors list\n    combinations_helper([], 0, n, colors, result)\n    # Return the final result\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Dog", "Cat", "CatBird", "Bird", "Fish"], 77]]}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "\ndef first_odd(numbers):\n    # Iterate through each number in the provided list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Return the first odd number found\n            return number\n    # If no odd number is found, return None\n    return None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "\ndef max_sum_list(lists):\n    # Initialize max_sum to a very small number\n    max_sum = float('-inf')\n    # Initialize max_list to None\n    max_list = None\n    \n    # Iterate through each inner list in the main list\n    for inner_list in lists:\n        # Calculate the sum of the current inner list\n        current_sum = sum(inner_list)\n        \n        # If the current sum is greater than the max_sum found so far\n        if current_sum > max_sum:\n            # Update max_sum to the current sum\n            max_sum = current_sum\n            # Update max_list to the current inner list\n            max_list = inner_list\n            \n    # Return the inner list with the highest sum\n    return max_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "\ndef max_run_uppercase(s: str) -> int:\n    # Initialize the maximum count of uppercase letters found\n    max_count = 0\n    # Initialize the current count of consecutive uppercase letters\n    current_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Increment the current count\n            current_count += 1\n        else:\n            # If we encounter a lowercase letter, check if the current count is greater than max_count\n            if current_count > max_count:\n                max_count = current_count\n            # Reset the current count to 0\n            current_count = 0\n    \n    # Final check to update max_count in case the string ends with uppercase letters\n    if current_count > max_count:\n        max_count = current_count\n    \n    # Return the maximum count of consecutive uppercase letters found\n    return max_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "\ndef is_product_even(numbers):\n    # Initialize a variable to track if we found an even number\n    is_even = False\n    \n    # Loop through each number in the list\n    for number in numbers:\n        # Check if the current number is even\n        if number % 2 == 0:\n            is_even = True  # Set is_even to True if we find an even number\n            break  # No need to check further, we can exit the loop\n    \n    # Return whether the product is even or not\n    return is_even\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "\ndef count_divisors(n):\n    # Initialize a counter for the number of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the count if it is a divisor\n            count += 1\n            \n    # Check if the count of divisors is even\n    if count % 2 == 0:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "\ndef check_smaller(tuple1, tuple2):\n    # Iterate through the indices of the first tuple\n    for i in range(len(tuple1)):\n        # Check if the corresponding element in the second tuple is not smaller\n        if tuple2[i] >= tuple1[i]:\n            return False  # Return False if any element is not smaller\n    return True  # Return True if all elements in the second tuple are smaller\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "\n# Define a function to check if k is in the tuple\ndef check_K(tup, k):\n    # Iterate through each element in the tuple\n    for element in tup:\n        # Check if the current element is equal to k\n        if element == k:\n            return True  # Return True if k is found\n    return False  # Return False if k is not found after checking all elements\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "\ndef volume_sphere(radius):\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the volume using the formula for the volume of a sphere\n    volume = (4/3) * pi * (radius ** 3)\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "\ndef sequence(n):\n    # Handle base cases for n = 1, 2, and 3\n    if n == 1 or n == 2:\n        return 1\n    if n == 3:\n        return 2\n    \n    # Initialize the sequence list with the first three values\n    seq = [0, 1, 1, 2]\n    \n    # Calculate the sequence values from 4 to n\n    for i in range(4, n + 1):\n        # The next value is the sum of the values at the positions defined by the previous two terms\n        next_value = seq[seq[i - 1]] + seq[seq[i - 2]]\n        seq.append(next_value)\n    \n    # Return the nth value in the sequence\n    return seq[n]\n\n# The logic for calculating the next value is now correctly referencing the previous terms.\n# The correct calculation should be:\n# P(n) = P(P(n-1)) + P(P(n-2))\n\n\ndef sequence(n):\n    # Handle base cases for n = 1, 2, and 3\n    if n == 1 or n == 2:\n        return 1\n    if n == 3:\n        return 2\n    \n    # Initialize the sequence list with the first three values\n    seq = [0, 1, 1, 2]\n    \n    # Calculate the sequence values from 4 to n\n    for i in range(4, n + 1):\n        # The next value is the sum of the values at the positions defined by the previous two terms\n        next_value = seq[seq[i - 1]] + seq[seq[i - 2]]\n        seq.append(next_value)\n    \n    # Return the nth value in the sequence\n    return seq[n]\n\n# This code should now correctly compute the nth number in the Newman-Conway sequence.\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "\n# Define a function to calculate the nth centered hexagonal number\ndef centered_hexagonal_number(n):\n    # Use the formula for centered hexagonal numbers\n    return 3 * n * (n - 1) + 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "\n# Define the function to calculate the surface area of a sphere\ndef surfacearea_sphere(radius: float) -> float:\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the surface area using the formula A = 4 * pi * r^2\n    surface_area = 4 * pi * (radius ** 2)\n    # Return the calculated surface area\n    return surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    # Initialize an empty dictionary to store the merged result\n    merged_dict = {}\n    \n    # Iterate through the first dictionary and add its items to the merged dictionary\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    \n    # Iterate through the second dictionary and add its items to the merged dictionary\n    for key, value in dict2.items():\n        merged_dict[key] = value\n    \n    # Iterate through the third dictionary and add its items to the merged dictionary\n    for key, value in dict3.items():\n        merged_dict[key] = value\n    \n    # Return the merged dictionary\n    return merged_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "\ndef freq_count(numbers):\n    # Create an empty dictionary to store the frequency of each number\n    frequency = {}\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # If the number is already a key in the dictionary\n        if number in frequency:\n            # Increment its count by 1\n            frequency[number] += 1\n        else:\n            # Otherwise, add the number to the dictionary with a count of 1\n            frequency[number] = 1\n            \n    # Return the dictionary containing the frequency of each number\n    return frequency\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "\n# Define a function that takes an integer n\ndef closest_num(n: int) -> int:\n    # Return the closest smaller number by subtracting 1 from n\n    return n - 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "\ndef find_Rotations(s: str) -> int:\n    # Store the original string to compare with\n    original = s\n    # Get the length of the string\n    length = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, length + 1):\n        # Rotate the string by moving the first character to the end\n        s = s[1:] + s[0]\n        # Check if the rotated string matches the original\n        if s == original:\n            return i  # Return the number of rotations needed\n    \n    return length  # This return is just a fallback; it should not be reached\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "\ndef len_log(words):\n    # Initialize a variable to keep track of the maximum length found\n    max_length = 0\n    \n    # Iterate through each word in the provided list\n    for word in words:\n        # Check if the current word's length is greater than the max_length\n        if len(word) > max_length:\n            # Update max_length to the length of the current word\n            max_length = len(word)\n    \n    # Return the maximum length found\n    return max_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "\ndef find_substring(string_list, substring):\n    # Iterate through each string in the provided list\n    for string in string_list:\n        # Check if the substring is present in the current string\n        if substring in string:\n            # If found, return True\n            return True\n    # If the loop completes without finding the substring, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "\ndef is_undulating(number: int) -> bool:\n    # Convert the number to a string to access each digit\n    num_str = str(number)\n    \n    # If the number has less than 2 digits, it is undulating\n    if len(num_str) < 2:\n        return True\n    \n    # Initialize the first and second distinct digits\n    first_digit = num_str[0]\n    second_digit = None\n    \n    # Find the second distinct digit\n    for digit in num_str:\n        if digit != first_digit:\n            second_digit = digit\n            break\n    \n    # If there is no second distinct digit, return False\n    if second_digit is None:\n        return False\n    \n    # Check the undulating pattern\n    for i in range(len(num_str)):\n        if i % 2 == 0:  # Even index\n            if num_str[i] != first_digit:\n                return False\n        else:  # Odd index\n            if num_str[i] != second_digit:\n                return False\n    \n    # If all checks passed, return True\n    return True\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[9]]}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "\ndef power(a: int, b: int) -> int:\n    # Check if the exponent b is 0\n    if b == 0:\n        return 1  # Any number to the power of 0 is 1\n    \n    # Check if the exponent b is negative\n    if b < 0:\n        result = 1\n        # Calculate the positive power\n        for i in range(1, -b + 1):\n            result *= a\n        return 1 / result  # Return the reciprocal for negative exponent\n    \n    result = 1\n    # Calculate the power for positive b\n    for i in range(1, b + 1):\n        result *= a\n    return result  # Return the final result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "\ndef even_Power_Sum(n: int) -> int:\n    # Initialize the sum to 0\n    sum = 0\n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even natural number\n        even_number = 2 * i\n        # Raise the even number to the fifth power and add to sum\n        sum += even_number ** 5\n    # Return the final sum\n    return sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "\ndef index_minimum(tuples_list):\n    # Initialize min_value to a large number\n    min_value = float('inf')\n    # Initialize min_name to an empty string\n    min_name = ''\n    \n    # Iterate through each tuple in the list\n    for name, value in tuples_list:\n        # If the second value of the tuple is less than min_value\n        if value < min_value:\n            # Update min_value to the current second value\n            min_value = value\n            # Update min_name to the current first value\n            min_name = name\n    \n    # Return the name associated with the smallest second value\n    return min_name\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[["Adam", 150, "NYC", true], ["Benjamin", 100, "LA", false], ["Charlie", 200, "Chicago", true], ["David", 125, "Miami", false]]]]}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "\ndef Find_Min_Length(lists):\n    # Initialize min_length to a large number\n    min_length = float('inf')\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Get the length of the current sublist\n        current_length = len(sublist)\n        \n        # Update min_length if the current length is smaller\n        if current_length < min_length:\n            min_length = current_length\n            \n    # Return the smallest length found\n    return min_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "\ndef frequency_lists(input_list):\n    # Create an empty dictionary to hold the frequency counts\n    frequency = {}\n    \n    # Loop through each sublist in the input list\n    for sublist in input_list:\n        # Loop through each element in the sublist\n        for element in sublist:\n            # If the element is already in the frequency dictionary\n            if element in frequency:\n                # Increment its count\n                frequency[element] += 1\n            else:\n                # Otherwise, add it to the dictionary with a count of 1\n                frequency[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "\ndef multiply_num(numbers):\n    # Initialize the product variable to 1\n    product = 1\n    \n    # Loop through each number in the input tuple\n    for number in numbers:\n        # Multiply the current number with the product\n        product *= number\n    \n    # Get the length of the input tuple\n    length_of_numbers = len(numbers)\n    \n    # Divide the product by the length of the tuple\n    result = product / length_of_numbers\n    \n    # Return the final result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "\ndef decimal_to_binary(n: int) -> str:\n    # Check if the input number is zero\n    if n == 0:\n        return '0'\n    \n    # Initialize an empty list to store the binary digits\n    binary_digits = []\n    \n    # Loop until the number is greater than zero\n    while n > 0:\n        # Get the remainder when n is divided by 2\n        remainder = n % 2\n        # Append the remainder to the list\n        binary_digits.append(str(remainder))\n        # Update n to be the quotient of n divided by 2\n        n = n // 2\n    \n    # Reverse the list of binary digits to get the correct order\n    binary_digits.reverse()\n    \n    # Join the list into a string and return it\n    return ''.join(binary_digits)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "\ndef divisor(n):\n    # Initialize a count variable to keep track of the number of divisors\n    count = 0\n    # Loop through all integers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, increment the count\n            count += 1\n    # Return the total count of divisors\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "\ndef binomial_coefficient(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    # Use a multiplicative approach to calculate C(n, k)\n    num = 1\n    denom = 1\n    for i in range(1, k + 1):\n        num *= (n - (i - 1))\n        denom *= i\n    return num // denom\n\ndef sum_Of_product(n):\n    # Initialize the total sum to 0\n    total_sum = 0\n    # Loop through all k from 0 to n-1\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n        # Add the product to the total sum\n        total_sum += product\n    # Return the final sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}