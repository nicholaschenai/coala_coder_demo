{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[2, 2, 2, 1, 1]] Output: True\n\nTests failed:\nNone",
    "code": "\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, return false\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, sides, side_length, 0)\n\n    def backtrack(self, nums, sides, side_length, index):\n        # If we have used all matchsticks, check if all sides are equal to side_length\n        if index == len(nums):\n            return all(side == side_length for side in sides)\n        \n        # Try to place the current matchstick in each side\n        for i in range(4):\n            # If adding the matchstick does not exceed the side length\n            if sides[i] + nums[index] <= side_length:\n                # Add the matchstick to the current side\n                sides[i] += nums[index]\n                \n                # Recur to place the next matchstick\n                if self.backtrack(nums, sides, side_length, index + 1):\n                    return True\n                \n                # Backtrack: remove the matchstick from the current side\n                sides[i] -= nums[index]\n        \n        return False\n",
    "full_code": "\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, return false\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, sides, side_length, 0)\n\n    def backtrack(self, nums, sides, side_length, index):\n        # If we have used all matchsticks, check if all sides are equal to side_length\n        if index == len(nums):\n            return all(side == side_length for side in sides)\n        \n        # Try to place the current matchstick in each side\n        for i in range(4):\n            # If adding the matchstick does not exceed the side length\n            if sides[i] + nums[index] <= side_length:\n                # Add the matchstick to the current side\n                sides[i] += nums[index]\n                \n                # Recur to place the next matchstick\n                if self.backtrack(nums, sides, side_length, index + 1):\n                    return True\n                \n                # Backtrack: remove the matchstick from the current side\n                sides[i] -= nums[index]\n        \n        return False\n",
    "reward": true,
    "program_code": "\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, return false\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, sides, side_length, 0)\n\n    def backtrack(self, nums, sides, side_length, index):\n        # If we have used all matchsticks, check if all sides are equal to side_length\n        if index == len(nums):\n            return all(side == side_length for side in sides)\n        \n        # Try to place the current matchstick in each side\n        for i in range(4):\n            # If adding the matchstick does not exceed the side length\n            if sides[i] + nums[index] <= side_length:\n                # Add the matchstick to the current side\n                sides[i] += nums[index]\n                \n                # Recur to place the next matchstick\n                if self.backtrack(nums, sides, side_length, index + 1):\n                    return True\n                \n                # Backtrack: remove the matchstick from the current side\n                sides[i] -= nums[index]\n        \n        return False\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: The task is to determine if a given set of matchsticks can be arranged to form a perfect square. Each matchstick has a specific length, and we must use all of them without breaking any. The output should be true if it's possible to form a square and false otherwise.\n\n2. **Conceptualize a solution first in plain English**: To solve this problem, we need to check if the total length of the matchsticks can be evenly divided into four equal parts (the sides of the square). If the total length is not divisible by 4, we can immediately return false. If it is divisible, we can use a backtracking approach to try to form four equal sides using the matchsticks. We will recursively attempt to add matchsticks to each side until either all matchsticks are used or we determine that it's impossible to form the square.\n\n3. **Write a pseudocode solution**:\n   ```\n   function makesquare(matchsticks):\n       total_length = sum(matchsticks)\n       if total_length % 4 != 0:\n           return false\n       side_length = total_length / 4\n       sort matchsticks in descending order\n       return backtrack(matchsticks, [0, 0, 0, 0], side_length, 0)\n\n   function backtrack(matchsticks, sides, side_length, index):\n       if index == length of matchsticks:\n           return all sides are equal to side_length\n       for each matchstick in matchsticks:\n           if adding matchstick to any side does not exceed side_length:\n               add matchstick to side\n               if backtrack(matchsticks, sides, side_length, index + 1):\n                   return true\n               remove matchstick from side\n       return false\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of matchsticks\n        total_length = sum(nums)\n        \n        # If total length is not divisible by 4, return false\n        if total_length % 4 != 0:\n            return False\n        \n        # Each side of the square should be of this length\n        side_length = total_length // 4\n        \n        # Sort matchsticks in descending order for better performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, sides, side_length, 0)\n\n    def backtrack(self, nums, sides, side_length, index):\n        # If we have used all matchsticks, check if all sides are equal to side_length\n        if index == len(nums):\n            return all(side == side_length for side in sides)\n        \n        # Try to place the current matchstick in each side\n        for i in range(4):\n            # If adding the matchstick does not exceed the side length\n            if sides[i] + nums[index] <= side_length:\n                # Add the matchstick to the current side\n                sides[i] += nums[index]\n                \n                # Recur to place the next matchstick\n                if self.backtrack(nums, sides, side_length, index + 1):\n                    return True\n                \n                # Backtrack: remove the matchstick from the current side\n                sides[i] -= nums[index]\n        \n        return False\n```",
    "no_parent": false,
    "dependency_used": false
}