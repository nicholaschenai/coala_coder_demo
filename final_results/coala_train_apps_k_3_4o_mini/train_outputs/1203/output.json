{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '3 3', '1 2', '2 1', '3 2'] Output: 0\n2\n2\n\nTests failed:\nNone",
    "code": "\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % (10**9 + 7)\n    return result\n\ndef calculate_combinations(n, k):\n    if k > n or k < 0:\n        return 0\n    return (factorial(n) * pow(factorial(k), -1, 10**9 + 7) * pow(factorial(n - k), -1, 10**9 + 7)) % (10**9 + 7)\n\ndef count_subsets(N, I, K):\n    if K > I or K < 1:\n        return 0\n    count_less_than_I = calculate_combinations(I - 1, K - 1)\n    count_greater_than_I = pow(2, N - I, 10**9 + 7)\n    return (count_less_than_I * count_greater_than_I) % (10**9 + 7)\n\ndef main():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        N, Q = map(int, input().split())\n        for __ in range(Q):\n            I, K = map(int, input().split())\n            result = count_subsets(N, I, K)\n            print(result)\n\nmain()\n",
    "full_code": "\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % (10**9 + 7)\n    return result\n\ndef calculate_combinations(n, k):\n    if k > n or k < 0:\n        return 0\n    return (factorial(n) * pow(factorial(k), -1, 10**9 + 7) * pow(factorial(n - k), -1, 10**9 + 7)) % (10**9 + 7)\n\ndef count_subsets(N, I, K):\n    if K > I or K < 1:\n        return 0\n    count_less_than_I = calculate_combinations(I - 1, K - 1)\n    count_greater_than_I = pow(2, N - I, 10**9 + 7)\n    return (count_less_than_I * count_greater_than_I) % (10**9 + 7)\n\ndef main():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        N, Q = map(int, input().split())\n        for __ in range(Q):\n            I, K = map(int, input().split())\n            result = count_subsets(N, I, K)\n            print(result)\n\nmain()\n",
    "reward": true,
    "program_code": "\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % (10**9 + 7)\n    return result\n\ndef calculate_combinations(n, k):\n    if k > n or k < 0:\n        return 0\n    return (factorial(n) * pow(factorial(k), -1, 10**9 + 7) * pow(factorial(n - k), -1, 10**9 + 7)) % (10**9 + 7)\n\ndef count_subsets(N, I, K):\n    if K > I or K < 1:\n        return 0\n    count_less_than_I = calculate_combinations(I - 1, K - 1)\n    count_greater_than_I = pow(2, N - I, 10**9 + 7)\n    return (count_less_than_I * count_greater_than_I) % (10**9 + 7)\n\ndef main():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        N, Q = map(int, input().split())\n        for __ in range(Q):\n            I, K = map(int, input().split())\n            result = count_subsets(N, I, K)\n            print(result)\n\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "1. **Restate the Problem in Plain English**:\n   The task is to determine how many subsets can be formed from the numbers 1 to N such that a specific number I appears in the K-th position of the subset when sorted. The output should be the count of such subsets for multiple queries, and since the result can be large, it should be given modulo \\(10^9 + 7\\).\n\n2. **Conceptualize a Solution**:\n   To solve this problem, we need to:\n   - Understand that for a number I to be in the K-th position of a subset, there must be exactly \\(K-1\\) numbers less than I in the subset.\n   - The remaining numbers in the subset can be chosen from the numbers greater than I.\n   - We can use combinatorial mathematics to calculate the number of ways to choose \\(K-1\\) numbers from the \\(I-1\\) numbers less than I and any number of numbers from the \\(N-I\\) numbers greater than I.\n   - The total number of valid subsets can be calculated using combinations and powers of 2.\n\n3. **Pseudocode Solution**:\n   ```\n   function calculate_combinations(n, k):\n       if k > n or k < 0:\n           return 0\n       return factorial(n) / (factorial(k) * factorial(n - k))\n\n   function count_subsets(N, I, K):\n       if K > I or K < 1:\n           return 0\n       count_less_than_I = calculate_combinations(I - 1, K - 1)\n       count_greater_than_I = 2^(N - I)\n       return (count_less_than_I * count_greater_than_I) % (10^9 + 7)\n\n   function main():\n       read T\n       for each test case:\n           read N, Q\n           for each query:\n               read I, K\n               result = count_subsets(N, I, K)\n               print(result)\n   ```\n\n4. **Final Python Code**:\n```python\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % (10**9 + 7)\n    return result\n\ndef calculate_combinations(n, k):\n    if k > n or k < 0:\n        return 0\n    return (factorial(n) * pow(factorial(k), -1, 10**9 + 7) * pow(factorial(n - k), -1, 10**9 + 7)) % (10**9 + 7)\n\ndef count_subsets(N, I, K):\n    if K > I or K < 1:\n        return 0\n    count_less_than_I = calculate_combinations(I - 1, K - 1)\n    count_greater_than_I = pow(2, N - I, 10**9 + 7)\n    return (count_less_than_I * count_greater_than_I) % (10**9 + 7)\n\ndef main():\n    MOD = 10**9 + 7\n    T = int(input())\n    for _ in range(T):\n        N, Q = map(int, input().split())\n        for __ in range(Q):\n            I, K = map(int, input().split())\n            result = count_subsets(N, I, K)\n            print(result)\n\nmain()\n``` \n\nThis code reads the number of test cases and queries, processes each query to calculate the number of valid subsets, and prints the results. The use of modular arithmetic ensures that we handle large numbers appropriately.",
    "no_parent": false,
    "dependency_used": false
}