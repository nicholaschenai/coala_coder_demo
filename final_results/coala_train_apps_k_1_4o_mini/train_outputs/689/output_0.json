{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '0 1', '1 -1'] Output: YES\n\nTests failed:\nNone",
    "code": "\ndef find_zebras(t, zebras):\n    # Create a dictionary to store the spit targets\n    spit_map = {}\n    \n    # First pass: populate the spit_map with positions and their spit targets\n    for i in range(t):\n        a, b = zebras[i]\n        spit_map[a] = a + b  # Store the target position for zebra at position a\n    \n    # Second pass: check for reciprocal spitting\n    for i in range(t):\n        a, b = zebras[i]\n        target_position = a + b  # Calculate where this zebra spits\n        # Check if the target zebra exists and if it spits back to the original zebra\n        if target_position in spit_map and spit_map[target_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no pairs found, print \"NO\"\n    print(\"NO\")\n\n# Read input\nt = int(input())\nzebras = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    zebras.append((a, b))\n\n# Call the function with the input data\nfind_zebras(t, zebras)\n",
    "full_code": "\ndef find_zebras(t, zebras):\n    # Create a dictionary to store the spit targets\n    spit_map = {}\n    \n    # First pass: populate the spit_map with positions and their spit targets\n    for i in range(t):\n        a, b = zebras[i]\n        spit_map[a] = a + b  # Store the target position for zebra at position a\n    \n    # Second pass: check for reciprocal spitting\n    for i in range(t):\n        a, b = zebras[i]\n        target_position = a + b  # Calculate where this zebra spits\n        # Check if the target zebra exists and if it spits back to the original zebra\n        if target_position in spit_map and spit_map[target_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no pairs found, print \"NO\"\n    print(\"NO\")\n\n# Read input\nt = int(input())\nzebras = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    zebras.append((a, b))\n\n# Call the function with the input data\nfind_zebras(t, zebras)\n",
    "reward": true,
    "program_code": "\ndef find_zebras(t, zebras):\n    # Create a dictionary to store the spit targets\n    spit_map = {}\n    \n    # First pass: populate the spit_map with positions and their spit targets\n    for i in range(t):\n        a, b = zebras[i]\n        spit_map[a] = a + b  # Store the target position for zebra at position a\n    \n    # Second pass: check for reciprocal spitting\n    for i in range(t):\n        a, b = zebras[i]\n        target_position = a + b  # Calculate where this zebra spits\n        # Check if the target zebra exists and if it spits back to the original zebra\n        if target_position in spit_map and spit_map[target_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no pairs found, print \"NO\"\n    print(\"NO\")\n\n# Read input\nt = int(input())\nzebras = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    zebras.append((a, b))\n\n# Call the function with the input data\nfind_zebras(t, zebras)\n",
    "program_name": "find_zebras",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n   The problem involves determining if there are two zebras in a jungle that spit at each other. Each zebra has a specific position and a distance it spits. If a zebra at position `a` spits `b` meters, it can hit another zebra located at position `a + b`. We need to check if there exists a pair of zebras such that one zebra spits at the other and vice versa.\n\n2. **Conceptualize a solution first in plain English:**\n   To solve this problem, we can use a dictionary to map each zebra's position to the position it spits at. We will iterate through each zebra's data, calculate the target position based on its spit distance, and check if the target zebra exists in our dictionary. If we find a zebra that spits back to the original zebra's position, we can conclude that they spit at each other.\n\n3. **Write a pseudocode solution:**\n   ```\n   Initialize an empty dictionary to store zebra positions and their spit targets\n   For each zebra in the input:\n       Read position a and spit distance b\n       Calculate target position as a + b\n       Store the target position in the dictionary with the key as a\n   For each zebra in the input again:\n       Read position a and spit distance b\n       Calculate target position as a + b\n       Check if the target position exists in the dictionary and if it points back to a\n       If found, print \"YES\" and exit\n   If no pairs found, print \"NO\"\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef find_zebras(t, zebras):\n    # Create a dictionary to store the spit targets\n    spit_map = {}\n    \n    # First pass: populate the spit_map with positions and their spit targets\n    for i in range(t):\n        a, b = zebras[i]\n        spit_map[a] = a + b  # Store the target position for zebra at position a\n    \n    # Second pass: check for reciprocal spitting\n    for i in range(t):\n        a, b = zebras[i]\n        target_position = a + b  # Calculate where this zebra spits\n        # Check if the target zebra exists and if it spits back to the original zebra\n        if target_position in spit_map and spit_map[target_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no pairs found, print \"NO\"\n    print(\"NO\")\n\n# Read input\nt = int(input())\nzebras = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    zebras.append((a, b))\n\n# Call the function with the input data\nfind_zebras(t, zebras)\n```",
    "no_parent": false,
    "dependency_used": false
}