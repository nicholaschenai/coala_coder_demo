{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '3 3', '1 2', '2 1', '3 2'] Output: 0\n2\n2\n\nTests failed:\nNone",
    "code": "\ndef precompute_factorials_and_inverses(n, mod):\n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[n] = pow(fact[n], mod - 2, mod)  # Fermat's little theorem for inverse\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\ndef comb(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef calculate_subsets(N, queries):\n    MOD = 10**9 + 7\n    fact, inv_fact = precompute_factorials_and_inverses(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less_than_I = I - 1\n            count_greater_than_I = N - I\n            ways_to_choose = comb(count_less_than_I, K - 1, fact, inv_fact, MOD)\n            total_subsets = pow(2, count_greater_than_I, MOD)\n            result = (ways_to_choose * total_subsets) % MOD\n            results.append(result)\n    \n    # Print all results\n    for res in results:\n        print(res)\n\n# Read number of test cases\nT = int(input())\nfor _ in range(T):\n    N, Q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    calculate_subsets(N, queries)\n",
    "full_code": "\ndef precompute_factorials_and_inverses(n, mod):\n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[n] = pow(fact[n], mod - 2, mod)  # Fermat's little theorem for inverse\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\ndef comb(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef calculate_subsets(N, queries):\n    MOD = 10**9 + 7\n    fact, inv_fact = precompute_factorials_and_inverses(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less_than_I = I - 1\n            count_greater_than_I = N - I\n            ways_to_choose = comb(count_less_than_I, K - 1, fact, inv_fact, MOD)\n            total_subsets = pow(2, count_greater_than_I, MOD)\n            result = (ways_to_choose * total_subsets) % MOD\n            results.append(result)\n    \n    # Print all results\n    for res in results:\n        print(res)\n\n# Read number of test cases\nT = int(input())\nfor _ in range(T):\n    N, Q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    calculate_subsets(N, queries)\n",
    "reward": true,
    "program_code": "\ndef precompute_factorials_and_inverses(n, mod):\n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[n] = pow(fact[n], mod - 2, mod)  # Fermat's little theorem for inverse\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\ndef comb(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef calculate_subsets(N, queries):\n    MOD = 10**9 + 7\n    fact, inv_fact = precompute_factorials_and_inverses(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less_than_I = I - 1\n            count_greater_than_I = N - I\n            ways_to_choose = comb(count_less_than_I, K - 1, fact, inv_fact, MOD)\n            total_subsets = pow(2, count_greater_than_I, MOD)\n            result = (ways_to_choose * total_subsets) % MOD\n            results.append(result)\n    \n    # Print all results\n    for res in results:\n        print(res)\n\n# Read number of test cases\nT = int(input())\nfor _ in range(T):\n    N, Q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    calculate_subsets(N, queries)\n",
    "program_name": "calculate_subsets",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n   We need to find the number of subsets from the set of natural numbers {1, 2, ..., N} such that a specific number I appears at the K-th position in the sorted order of the subset. The output should be the count of such subsets for multiple queries, and since the result can be large, we need to return it modulo \\(10^9 + 7\\).\n\n2. **Conceptualize a solution first in plain English:**\n   To solve this problem, we need to consider how subsets are formed and how to determine the position of a specific number within those subsets. The key steps are:\n   - For a number I to be at position K in a subset, there must be exactly K-1 numbers less than I in the subset.\n   - The remaining numbers can be any of the numbers greater than I.\n   - We can use combinatorial mathematics to calculate the number of ways to choose K-1 numbers from the numbers less than I and any number of numbers from those greater than I.\n   - We will precompute factorials and their modular inverses to efficiently calculate combinations.\n\n3. **Write a pseudocode solution:**\n   ```\n   function calculate_subsets(N, queries):\n       MOD = 10**9 + 7\n       precompute factorials and inverses up to N\n       \n       for each query (I, K):\n           if K > I or K < 1:\n               output 0\n           else:\n               count_less_than_I = I - 1\n               count_greater_than_I = N - I\n               ways_to_choose = comb(count_less_than_I, K - 1)\n               total_subsets = 2 ** count_greater_than_I\n               result = (ways_to_choose * total_subsets) % MOD\n               output result\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef precompute_factorials_and_inverses(n, mod):\n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[n] = pow(fact[n], mod - 2, mod)  # Fermat's little theorem for inverse\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\ndef comb(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef calculate_subsets(N, queries):\n    MOD = 10**9 + 7\n    fact, inv_fact = precompute_factorials_and_inverses(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K < 1:\n            results.append(0)\n        else:\n            count_less_than_I = I - 1\n            count_greater_than_I = N - I\n            ways_to_choose = comb(count_less_than_I, K - 1, fact, inv_fact, MOD)\n            total_subsets = pow(2, count_greater_than_I, MOD)\n            result = (ways_to_choose * total_subsets) % MOD\n            results.append(result)\n    \n    # Print all results\n    for res in results:\n        print(res)\n\n# Read number of test cases\nT = int(input())\nfor _ in range(T):\n    N, Q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    calculate_subsets(N, queries)\n```",
    "no_parent": false,
    "dependency_used": false
}