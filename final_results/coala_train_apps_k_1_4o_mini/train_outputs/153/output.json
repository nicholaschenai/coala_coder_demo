{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[2, 2, 2, 1, 1]] Output: True\n\nTests failed:\nNone",
    "code": "\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # Check if the total length is divisible by 4\n        if total_length % 4 != 0:\n            return False\n        \n        # Determine the target length for each side of the square\n        side_length = total_length // 4\n        \n        # Sort the matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the current length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, 0, sides, side_length)\n\n    def backtrack(self, nums, index, sides, target):\n        # If we have used all matchsticks, check if all sides are equal to the target\n        if index == len(nums):\n            return all(side == target for side in sides)\n        \n        # Try to place the current matchstick in one of the four sides\n        for i in range(4):\n            # If adding the matchstick does not exceed the target length\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]  # Place the matchstick\n                # Recur to place the next matchstick\n                if self.backtrack(nums, index + 1, sides, target):\n                    return True\n                sides[i] -= nums[index]  # Backtrack\n        \n        return False  # If no valid placement found\n",
    "full_code": "\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # Check if the total length is divisible by 4\n        if total_length % 4 != 0:\n            return False\n        \n        # Determine the target length for each side of the square\n        side_length = total_length // 4\n        \n        # Sort the matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the current length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, 0, sides, side_length)\n\n    def backtrack(self, nums, index, sides, target):\n        # If we have used all matchsticks, check if all sides are equal to the target\n        if index == len(nums):\n            return all(side == target for side in sides)\n        \n        # Try to place the current matchstick in one of the four sides\n        for i in range(4):\n            # If adding the matchstick does not exceed the target length\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]  # Place the matchstick\n                # Recur to place the next matchstick\n                if self.backtrack(nums, index + 1, sides, target):\n                    return True\n                sides[i] -= nums[index]  # Backtrack\n        \n        return False  # If no valid placement found\n",
    "reward": true,
    "program_code": "\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # Check if the total length is divisible by 4\n        if total_length % 4 != 0:\n            return False\n        \n        # Determine the target length for each side of the square\n        side_length = total_length // 4\n        \n        # Sort the matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the current length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, 0, sides, side_length)\n\n    def backtrack(self, nums, index, sides, target):\n        # If we have used all matchsticks, check if all sides are equal to the target\n        if index == len(nums):\n            return all(side == target for side in sides)\n        \n        # Try to place the current matchstick in one of the four sides\n        for i in range(4):\n            # If adding the matchstick does not exceed the target length\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]  # Place the matchstick\n                # Recur to place the next matchstick\n                if self.backtrack(nums, index + 1, sides, target):\n                    return True\n                sides[i] -= nums[index]  # Backtrack\n        \n        return False  # If no valid placement found\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: \n   The task is to determine if a given set of matchsticks can be arranged to form a perfect square. Each matchstick has a specific length, and we must use all of them exactly once without breaking any. The output should be true if it's possible to form a square and false otherwise.\n\n2. **Conceptualize a solution first in plain English**: \n   To solve this problem, we need to check if the total length of all matchsticks can be evenly divided into four equal parts (since a square has four sides). If the total length is not divisible by four, we can immediately return false. If it is divisible, we can use a backtracking approach to try to build each side of the square recursively, ensuring that we do not exceed the target length for each side.\n\n3. **Write a pseudocode solution**:\n   ```\n   function makesquare(nums):\n       total_length = sum(nums)\n       if total_length % 4 != 0:\n           return false\n       side_length = total_length / 4\n       sort nums in descending order\n       return backtrack(nums, 0, [0, 0, 0, 0], side_length)\n\n   function backtrack(nums, index, sides, target):\n       if index == length of nums:\n           return all sides are equal to target\n       for i from 0 to 3:\n           if sides[i] + nums[index] <= target:\n               sides[i] += nums[index]\n               if backtrack(nums, index + 1, sides, target):\n                   return true\n               sides[i] -= nums[index]\n       return false\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\nclass Solution:\n    def makesquare(self, nums: list[int]) -> bool:\n        # Calculate the total length of all matchsticks\n        total_length = sum(nums)\n        \n        # Check if the total length is divisible by 4\n        if total_length % 4 != 0:\n            return False\n        \n        # Determine the target length for each side of the square\n        side_length = total_length // 4\n        \n        # Sort the matchsticks in descending order for better backtracking performance\n        nums.sort(reverse=True)\n        \n        # Initialize an array to keep track of the current length of each side\n        sides = [0] * 4\n        \n        # Start the backtracking process\n        return self.backtrack(nums, 0, sides, side_length)\n\n    def backtrack(self, nums, index, sides, target):\n        # If we have used all matchsticks, check if all sides are equal to the target\n        if index == len(nums):\n            return all(side == target for side in sides)\n        \n        # Try to place the current matchstick in one of the four sides\n        for i in range(4):\n            # If adding the matchstick does not exceed the target length\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]  # Place the matchstick\n                # Recur to place the next matchstick\n                if self.backtrack(nums, index + 1, sides, target):\n                    return True\n                sides[i] -= nums[index]  # Backtrack\n        \n        return False  # If no valid placement found\n```",
    "no_parent": false,
    "dependency_used": false
}